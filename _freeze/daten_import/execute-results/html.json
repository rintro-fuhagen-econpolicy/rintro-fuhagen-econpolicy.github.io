{
  "hash": "930c14d1134703ae2bd6d4f7008666bc",
  "result": {
    "engine": "knitr",
    "markdown": "# Daten importieren {#sec-daten-import}\n\n\n::: {.cell}\n\n:::\n\n\nBisher haben wir Objekte in R selbst erstellt oder in R Packages enthaltene Datensätze verwendet. In diesem Abschnitt lernen wir, wie man Datensätze in R importiert. Dazu erstellen wir zuerst in dem Ordner unseres R-Projects einen Datenordner und folgende Unterordner:\n\n```\nr_intro/\n├── data/\n│   ├── raw/           # Originaldaten\n│   └── processed/     # Bearbeitete Daten\n```\n\nAnschließend laden wir ein Set an unterschiedlichen Datensatz-Arten aus dem Github-Ordner des Kurses in den `raw` Ordner, in dem wir entweder alle Dateien in diesem [Github-Ordner](https://github.com/rintro-fuhagen-econpolicy/rintro-fuhagen-econpolicy.github.io/tree/main/data/raw/earnings_data) manuell herunterladen, oder den folgenden Code in R ausführen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepo_url <- \"https://github.com/rintro-fuhagen-econpolicy/rintro-fuhagen-econpolicy.github.io/archive/refs/heads/main.zip\"\ndownload.file(repo_url, destfile = \"repo.zip\")\nunzip(\"repo.zip\")\nfile.copy(\"rintro-fuhagen-econpolicy.github.io-main/data/raw/earnings_data\", \n          \"data/raw\", \n          recursive = TRUE)\nunlink(\"repo.zip\")\nunlink(\"rintro-fuhagen-econpolicy.github.io-main\", recursive = TRUE)\nrm(repo_url)\n```\n:::\n\n\n## Datenformate\n\nIn der Praxis begegnen dir verschiedene Datenformate, die mit unterschiedlichen Funktionen in R eingelesen werden. @tbl-data-formats gibt einen Überblick über die gebräuchlichsten Formate.\n\n\n::: {#tbl-data-formats .cell tbl-cap='Datensatzformate in der Praxis (Auswahl)'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Dateiformat </th>\n   <th style=\"text-align:left;\"> Typisch für </th>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Lesefunktion </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> csv </td>\n   <td style=\"text-align:left;\"> Allgemein </td>\n   <td style=\"text-align:left;\"> readr (tidyverse) </td>\n   <td style=\"text-align:left;\"> read_csv() </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> rds </td>\n   <td style=\"text-align:left;\"> R </td>\n   <td style=\"text-align:left;\"> readr (tidyverse) </td>\n   <td style=\"text-align:left;\"> read_rds() </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> txt </td>\n   <td style=\"text-align:left;\"> Allgemein </td>\n   <td style=\"text-align:left;\"> readr (tidyverse) </td>\n   <td style=\"text-align:left;\"> read_delim() </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> xlsx </td>\n   <td style=\"text-align:left;\"> MS Office </td>\n   <td style=\"text-align:left;\"> readxl </td>\n   <td style=\"text-align:left;\"> read_excel() </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> dta </td>\n   <td style=\"text-align:left;\"> Stata </td>\n   <td style=\"text-align:left;\"> haven </td>\n   <td style=\"text-align:left;\"> read_dta() </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Daten einlesen\n\n### CSV-Dateien\n\nDas CSV-Format (Comma-Separated Values) speichert tabellarische Daten als Text, wobei jede Zeile eine Beobachtung und jede Spalte einen Wert enthält, getrennt durch Kommata oder andere Trennzeichen. Beim Import in R müssen wir auf das korrekte Trennzeichen achten, damit die Zahlen korrekt eingelesen werden.\n\nCSV-Dateien können mit der Funktion `read_csv()` aus dem `tidyverse`/`readr` Package eingelesen werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings <- read_csv(\"data/raw/earnings_data/earnings.csv\")\nearnings\n#> # A tibble: 10 × 4\n#>   Names        age.in.years Nationalität  `inc in Eur`\n#>   <chr>               <dbl> <chr>         <chr>       \n#> 1 Anna Maria             33 DE            1689        \n#> 2 Ben                    NA N/A           875         \n#> 3 Clara                  21 International 2000€       \n#> 4 Dimitri                28 EU            2299        \n#> 5 Emilia-Luise           29 DE            2522        \n#> 6 Fatima                 23 DE            1060        \n#> # ℹ 4 more rows\n```\n:::\n\n\nInternational werden die einzelnen Spalten mit einem Komma (,) getrennt. Dies ist auch das Default-Trennzeichen bei `read_csv()`. Da in der deutschen Sprache dieses als Zeichen für Dezimalstellen verwendet wird, wird hier das Semikolon/der Strichpunkt (;) als Trennzeichen verwendet. Verwenden wir das falsche Trennzeichen beim Einlesen von CSV-Dateien mit diesem Trennzeichen, werden die Daten falsch eingelesen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"data/raw/earnings_data/earnings_de.csv\")\n#> # A tibble: 10 × 1\n#>   `Names;age.in.years;Nationalität;inc in Eur`\n#>   <chr>                                       \n#> 1 Anna Maria;33;DE;1689                       \n#> 2 Ben;NA;N/A;875                              \n#> 3 Clara;21;International;2000€                \n#> 4 Dimitri;28;EU;2299                          \n#> 5 Emilia-Luise;29;DE;2522                     \n#> 6 Fatima;23;DE;1060                           \n#> # ℹ 4 more rows\n```\n:::\n\n\nStattdessen müssen wir bei einer solchen Encodierung `read_csv2()` verwenden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv2(\"data/raw/earnings_data/earnings_de.csv\")\n#> # A tibble: 10 × 4\n#>   Names        age.in.years Nationalität  `inc in Eur`\n#>   <chr>               <dbl> <chr>         <chr>       \n#> 1 Anna Maria             33 DE            1689        \n#> 2 Ben                    NA N/A           875         \n#> 3 Clara                  21 International 2000€       \n#> 4 Dimitri                28 EU            2299        \n#> 5 Emilia-Luise           29 DE            2522        \n#> 6 Fatima                 23 DE            1060        \n#> # ℹ 4 more rows\n```\n:::\n\n\n::: {.callout-warning}\n#### Häufige Probleme mit CSV-Dateien\n\n- *Trennzeichen*: `read_csv(\"datei.csv\")` bei `,` als Trennzeichen, `read_csv2(\"datei.csv\")` bei `;`\n- *Encoding*: Bei Problemen mit Sonderzeichen muss das Encoding spezifiziert werden, etwa `read_csv(\"datei.csv\", locale = locale(encoding = \"latin1\"))`\n- *Dezimaltrennzeichen*: Ebenfalls über das `locale` Argument,`locale = locale(decimal_mark = \",\")`\n- *Falsche Spaltentypen*: Mit `col_types` spezifizieren\n:::\n\n### RDS-Dateien\n\nRDS ist ein R-spezifisches Format, das ein einzelnes R-Objekt speichert. RDS speichert Objekte in nativer R-Struktur, inklusive Datentypen, Faktoren, Datum/Zeit und sogar komplexer Objekte wie Modelle, wodurch beim Einlesen keine Umwandlungen nötig sind. RDS-Dateien sind oft kleiner und schneller zu lesen als Textdateien, da keine Konvertierung von und zu Text nötig ist.\n\nWir können RDS-Dateien mit `read_rds()` einlesen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings <- read_rds(\"data/raw/earnings_data/earnings.rds\")\n```\n:::\n\n\n::: callout-note\n#### RData-Format\n\nEin weiteres R-spezifisches Format ist RData. RData kann mehrere Objekte speichern:\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- 6:10\nnames <- c(\"Anna\", \"Ben\", \"Clara\")\nsave(numbers, names, file = \"data/raw/earnings_data/multidata.RData\")\nrm(numbers, names)\n```\n:::\n\n\nMit `load()` werden alle in dieser Datei abgespeicherten R-Objekte importiert:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"data/raw/earnings_data/multidata.RData\")\n```\n:::\n\n:::\n\n### Excel-Spreadsheets\n\nUm Excel-Spreadsheets einzulesen benötigt man in R ein zusätzliches Package (`readxl`). Mit der Funktion `read_excel()` können sowohl `.xlsx` als auch `.xls` Dateien eingeladen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nread_excel(\"data/raw/earnings_data/earnings.xlsx\")\n#> # A tibble: 10 × 4\n#>   Names        age.in.years Nationalität  `inc in Eur`\n#>   <chr>               <dbl> <chr>         <chr>       \n#> 1 Anna Maria             33 DE            1689        \n#> 2 Ben                    NA N/A           875         \n#> 3 Clara                  21 International 2000€       \n#> 4 Dimitri                28 EU            2299        \n#> 5 Emilia-Luise           29 DE            2522        \n#> 6 Fatima                 23 DE            1060        \n#> # ℹ 4 more rows\n```\n:::\n\n\n\nPer Default importiert diese Funktion immer den Datensatz aus dem ersten Tabellenblatt. Mit dem Argument `sheet = ...` können wir das Tabellenblatt wählen. Möglich ist sowohl, die Nummer des Tabellenblatts als Zahl anzugeben, als auch den Namen des Tabellenblatts in Anführungszeichen anzugeben. Mit dem Argument `range = ...` können wir außerdem den Bereich des Tabellenblatts angeben, den wir einlesen wollen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_excel(\"data/raw/earnings_data/earnings.xlsx\", sheet = 1, range = \"A1:C3\")\n#> # A tibble: 2 × 3\n#>   Names      age.in.years Nationalität\n#>   <chr>             <dbl> <chr>       \n#> 1 Anna Maria           33 DE          \n#> 2 Ben                  NA N/A\n```\n:::\n\n\nUm einen Überblick über die Tabellenblätter eines Spreadsheets zu bekommen, ist die Funktion `excel_sheets()` im `readxl` Package hilfreich:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexcel_sheets(\"data/raw/earnings_data/earnings.xlsx\")\n#> [1] \"Sheet1\"\n```\n:::\n\n\n### Stata-Datensätze\n\nStata ist eine alternative Statistiksoftware, die in den Wirtschaftswissenschaften immer noch häufig verwendet wird. Für das Speichern von Datensätzen verwendet Stata das `.dta`-Format. Dieses speichert sowohl die Daten als auch Variablen- und Wertelabels, sodass beim Einlesen in R oder Stata die Struktur, Kategorien und Labels erhalten bleiben.\n\nFür das Einlesen von Stata-Datensätzen verwenden wir das `haven` Package und die Funktion ``:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(haven)\nread_dta(\"data/raw/earnings_data/earnings.dta\")\n#> # A tibble: 10 × 4\n#>   names          age nationality        income\n#>   <chr>        <dbl> <dbl+lbl>           <dbl>\n#> 1 Anna Maria      33  1 [DE]              1689\n#> 2 Ben             NA NA                    875\n#> 3 Clara           21  3 [International]   2000\n#> 4 Dimitri         28  2 [EU]              2299\n#> 5 Emilia-Luise    29  1 [DE]              2522\n#> 6 Fatima          23  1 [DE]              1060\n#> # ℹ 4 more rows\n```\n:::\n\n\nIn Stata werden Faktorvariablen wie in diesem Fall `nationality` numerisch abgespeichert und mit Labels versehen. Um diese in R miteinzulesen, können wir `haven::as_factor()` verwenden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_dta(\"data/raw/earnings_data/earnings.dta\") |>\n  mutate(nationality = as_factor(nationality))\n#> # A tibble: 10 × 4\n#>   names          age nationality   income\n#>   <chr>        <dbl> <fct>          <dbl>\n#> 1 Anna Maria      33 DE              1689\n#> 2 Ben             NA <NA>             875\n#> 3 Clara           21 International   2000\n#> 4 Dimitri         28 EU              2299\n#> 5 Emilia-Luise    29 DE              2522\n#> 6 Fatima          23 DE              1060\n#> # ℹ 4 more rows\n```\n:::\n\n\n::: callout-tip\n#### Automatisiertes Faktor-Einlesen bei dta\n\nDamit wir nicht bei jeder Variable im Datensatz überprüfen müssen, ob es sich um eine Label-Variable handelt, können wir auch folgenden Code verwenden, der über alle Variable (`across(.)`) die Funktion `as_factor()` anwendet, falls es sich dabei um eine Label-Variable handelt (`where(is.labelled)`):\n\n::: {.cell}\n\n```{.r .cell-code}\nread_dta(\"data/raw/earnings_data/earnings.dta\") |>\n  mutate(across(where(is.labelled), as_factor))\n```\n:::\n\n:::\n\n### Weitere Dateiformate\n\nDie Funktion `read_delim()` kann in R verwendet werden, um Datensätze mit beliebigem Trennzeichen einzulesen. Sie versucht dabei, das Trennzeichen automatisch zu erkennen. Wir können damit etwa eine Textdatei (.txt) einlesen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_delim(\"data/raw/earnings_data/earnings_tab.txt\")\n#> # A tibble: 10 × 4\n#>   Names        age.in.years Nationalität  `inc in Eur`\n#>   <chr>               <dbl> <chr>         <chr>       \n#> 1 Anna Maria             33 DE            1689        \n#> 2 Ben                    NA N/A           875         \n#> 3 Clara                  21 International 2000€       \n#> 4 Dimitri                28 EU            2299        \n#> 5 Emilia-Luise           29 DE            2522        \n#> 6 Fatima                 23 DE            1060        \n#> # ℹ 4 more rows\n```\n:::\n\n\nBei diesem Text-File wird der Tabulator als Trennzeichen verwendet und von R auch korrekt beim Einlesen erkannt. Wir können das Trennzeichen aber auch explizit über das `delim = value`-Argument spezifizieren:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_delim(\"data/raw/earnings_data/earnings_tab.txt\", delim = \"\\t\")\n```\n:::\n\n\n\n::: callout-warning\n#### Probleme mit Trennzeichen\n\nBei TXT-Dateien oder anderen allgemeinen Datensätzen kann es jedoch immer wieder zu Problemen kommen, wenn das Trennzeichen auch innerhalb einer Variable verwendet wird. Wurde zum Beispiel ein Datensatz als TXT-Datei mit Leerzeichen als Trennzeichen abgespeichert, so führt dies beim Einlesen zu folgendem Problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_delim(\"data/raw/earnings_data/earnings_space.txt\", delim = \" \")\n#> # A tibble: 10 × 6\n#>   Names        age.in.years Nationalität  inc       `in`     Eur  \n#>   <chr>        <chr>        <chr>         <chr>     <chr>    <lgl>\n#> 1 Anna         Maria        33            \"DE\"      \"1689\\r\" NA   \n#> 2 Ben          <NA>         N/A           \"875\\r\"    <NA>    NA   \n#> 3 Clara        21           International \"2000€\\r\"  <NA>    NA   \n#> 4 Dimitri      28           EU            \"2299\\r\"   <NA>    NA   \n#> 5 Emilia-Luise 29           DE            \"2522\\r\"   <NA>    NA   \n#> 6 Fatima       23           DE            \"1060\\r\"   <NA>    NA   \n#> # ℹ 4 more rows\n```\n:::\n\n\nDa die erste Beobachtung der Namensvariable (*Anna Maria*) und die Variablenbezeichnung `inc in Eur` Leerzeichen enthalten, werden hier die Werte in die nächsten Spalten verschoben. Daher ist es ratsam beim Exportieren von eigenen Datensätzen auf Formate zurückzugreifen, die von R problemlos richtig gelesen werden (etwa RDS oder CSV).\n:::\n\n## Daten ansehen\n\nNach dem Import von Daten sollte man sich den Datensatz immer zunächst genau ansehen, um Struktur, Datentypen und mögliche Probleme frühzeitig zu erkennen. Bisher haben wir uns den Datensatz durch Eingabe des Objektnamens anzeigen lassen. Sollte ein Datensatz als *Dataframe* und nicht als *Tibble* geladen sein, hat dies den Nachteil, dass hier der gesamte Datensatz in der Konsole ausgegeben wird. Bei kleinen Datensätzen macht das kaum einen Unterschied, aber bei größeren Daten kann die vollständige Ausgabe sehr unübersichtlich werden und die Konsole „überfluten“.\n\nEs ist daher besser, sich in der Konsole nur Teile eines Datensatzes anzeigen zu lassen. In Base R bieten sich dafür Funktionen wie head() und tail() (Anzeigen der ersten bzw. letzten Zeilen):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(earnings, n = 5)\n#> # A tibble: 5 × 4\n#>   Names        age.in.years Nationalität  `inc in Eur`\n#>   <chr>               <int> <chr>         <chr>       \n#> 1 Anna Maria             33 DE            1689        \n#> 2 Ben                    NA N/A           875         \n#> 3 Clara                  21 International 2000€       \n#> 4 Dimitri                28 EU            2299        \n#> 5 Emilia-Luise           29 DE            2522\n```\n:::\n\n\nIm `tidyverse` Package bietet die Funktion `glimpse()` eine kompakte Übersicht:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(earnings)\n#> Rows: 10\n#> Columns: 4\n#> $ Names        <chr> \"Anna Maria\", \"Ben\", \"Clara\", \"Dimitri\", \"Emilia-Luise…\n#> $ age.in.years <int> 33, NA, 21, 28, 29, 23, 32, 23, 27, 21\n#> $ Nationalität <chr> \"DE\", \"N/A\", \"International\", \"EU\", \"DE\", \"DE\", \"DE\", …\n#> $ `inc in Eur` <chr> \"1689\", \"875\", \"2000€\", \"2299\", \"2522\", \"1060\", \"1781\"…\n```\n:::\n\n\nNeben den ersten Werten in jeder Variable sehen wir auch, dass unser Datensatz aus 10 Zeilen und 4 Spalten besteht, sowie den Datentyp der jeweiligen Variablen (z.b. `character` bei `earnings$Names`).\n\nUm uns den ganzen Datensatz anzusehen, können wir uns den Datensatz in einem separaten Fenster öffnen. Dies geschieht entweder durch Doppelklick auf den Datensatz im Environment-Fenster oder durch die Funktionen `View()` (Base R) bzw. `view()` (`tidyverse`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nview(earnings)\n```\n:::\n\n\nDadurch öffnet sich im R-Script-Panel ein neues Fenster mit dem Datensatz (@fig-view-data). Um uns den Datensatz genauer anzusehen, haben wir auch die Möglichkeit, Daten zu filtern (grüne Markierung), zu suchen (rote Markierung) oder den Datensatz anhand einer bestimmten Variable zu sortieren (blaue Markierung).\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Separates Datensatz-Fenster in R.\n](images/view_data.png){#fig-view-data fig-alt='Datensatz-Fenster in R mit Herhorhebungen der Filter-, Sortier- und Suchfunktion.'}\n:::\n:::\n\n\n## Daten bereinigen\n\nNachdem wir einen Datensatz importiert haben müssen wir diesen häufig bereinigen, bevor wir mit der Analyse oder Weiterverarbeitung starten. Wesentliche Punkte sind dabei die Vereinheitlichung der Variablennamen, eine Korrektur falscher Datentypen und die Identifizierung fehlender Werte.\n\nDurch einen ersten Blick auf die Daten bekommen wir schnell einen Überblick, welche Probleme im Datensatz bestehen:\n\n\n::: {.cell}\n\n```\n#> # A tibble: 10 × 4\n#>    Names        age.in.years Nationalität  `inc in Eur`\n#>    <chr>               <dbl> <chr>         <chr>       \n#>  1 Anna Maria             33 DE            1689        \n#>  2 Ben                    NA N/A           875         \n#>  3 Clara                  21 International 2000€       \n#>  4 Dimitri                28 EU            2299        \n#>  5 Emilia-Luise           29 DE            2522        \n#>  6 Fatima                 23 DE            1060        \n#>  7 Gerda                  32 DE            1781        \n#>  8 Hannah                 23 EU            2463        \n#>  9 Ismail                 27 International 1442        \n#> 10 Johanna                21 DE            1404\n```\n:::\n\n\nDer `earnings`-Datensatz zeigt dabei mehrere typische Probleme:\n- *Fehlende Werte*: In der Variable `Nationalität` wurde ein fehlender Wert nicht als `NA` erkannt, sondern als Text eingelesen (*N/A*).\n- *Variablennamen*: Die Namen sind uneinheitlich und enthalten Großbuchstaben, Sonderzeichen, Leerzeichen oder Punkte – sie widersprechen damit den Best Practices zur Namensgebung.\n- *Datentypen*: Die Variable *incEur* wurde als `character` eingelesen, sollte aber eigentlich numerisch sein.\n\nDiese Probleme können wir mit den in @sec-daten-transform vorgestellten Operationen lösen. Es ist jedoch sinnvoll, den Einleseprozess so anzupassen, dass die Daten direkt korrekt eingelesen werden.\n\n### Fehlende Werte\n\nR interpretiert beim CSV-Import standardmäßig nur leere Felder oder den String *NA* als fehlende Werte (`NA`). In unserem Datensatz fehlt jedoch auch die zweite Beobachtung in `Nationalität`, die als *N/A* codiert wurde. Mit `read_csv()` können wir über das Argument `na = ...` festlegen, welche Werte als `NA` eingelesen werden sollen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings <- read_csv(\"data/raw/earnings_data/earnings.csv\", na = c(\"\", \"NA\", \"N/A\"))\nearnings\n#> # A tibble: 10 × 4\n#>    Names        age.in.years Nationalität  `inc in Eur`\n#>    <chr>               <dbl> <chr>         <chr>       \n#>  1 Anna Maria             33 DE            1689        \n#>  2 Ben                    NA <NA>          875         \n#>  3 Clara                  21 International 2000€       \n#>  4 Dimitri                28 EU            2299        \n#>  5 Emilia-Luise           29 DE            2522        \n#>  6 Fatima                 23 DE            1060        \n#>  7 Gerda                  32 DE            1781        \n#>  8 Hannah                 23 EU            2463        \n#>  9 Ismail                 27 International 1442        \n#> 10 Johanna                21 DE            1404\n```\n:::\n\n\n\n### Variablennamen\n\nVariablen sollten – wie alle R-Objekte – aussagekräftig und einheitlich benannt werden. In diesem Kurs orientieren wir uns dabei an der snake_case-Konvention. Die ursprünglichen Variablennamen widersprechen dieser Logik, da sie Großbuchstaben, Sonderzeichen, Leerzeichen oder Punkte als Trennzeichen enthalten. Außerdem transportieren manche Namen zu viele Informationen: Dass das Alter in Jahren oder das Einkommen in Euro gemessen wird, ist in der Regel aus dem Kontext des Datensatzes klar und somit redundant.\n\nUm Variablennamen gezielt zu ändern, können wir `rename(new_name = old_name)` verwenden. Enthält ein Variablenname Leerzeichen, muss er in Backticks (`` ` ``) gesetzt werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings <- earnings |>\n  rename(\n    name = Names,\n    age = age.in.years,\n    nationality = Nationalität,\n    income = `inc in Eur`\n  )\nearnings\n#> # A tibble: 10 × 4\n#>    name           age nationality   income\n#>    <chr>        <dbl> <chr>         <chr> \n#>  1 Anna Maria      33 DE            1689  \n#>  2 Ben             NA <NA>          875   \n#>  3 Clara           21 International 2000€ \n#>  4 Dimitri         28 EU            2299  \n#>  5 Emilia-Luise    29 DE            2522  \n#>  6 Fatima          23 DE            1060  \n#>  7 Gerda           32 DE            1781  \n#>  8 Hannah          23 EU            2463  \n#>  9 Ismail          27 International 1442  \n#> 10 Johanna         21 DE            1404\n```\n:::\n\n\nBei Datensätzen mit vielen Variablen ist eine einzelne Umbenennung mühsam. Hier kann die Funktion `janitor::clean_names()` (aus dem gleichnamigen Paket) helfen, alle Variablennamen automatisch in snake_case zu übersetzen. Einzelne Anpassungen lassen sich anschließend bei Bedarf noch vornehmen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"data/raw/earnings_data/earnings.csv\", na = c(\"\", \"NA\", \"N/A\")) |>\n  janitor::clean_names(case = \"snake\")\n#> # A tibble: 10 × 4\n#>    names        age_in_years nationalitat  inc_in_eur\n#>    <chr>               <dbl> <chr>         <chr>     \n#>  1 Anna Maria             33 DE            1689      \n#>  2 Ben                    NA <NA>          875       \n#>  3 Clara                  21 International 2000€     \n#>  4 Dimitri                28 EU            2299      \n#>  5 Emilia-Luise           29 DE            2522      \n#>  6 Fatima                 23 DE            1060      \n#>  7 Gerda                  32 DE            1781      \n#>  8 Hannah                 23 EU            2463      \n#>  9 Ismail                 27 International 1442      \n#> 10 Johanna                21 DE            1404\n```\n:::\n\n\n### Datentypen\n\nWenn Variablen im Originaldatensatz nicht sauber codiert sind, kann R sie im falschen Typ einlesen. In unserem Beispiel wurde das Einkommen bei der dritten Beobachtung mit einem Euro-Zeichen versehen, sodass R die Variable als `character` interpretiert. Eine direkte Umwandlung mit `as.numeric()` würde diese Beobachtung in `NA` recodieren, da sie keinen reinen Zahlenwert enthält:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings |>\n  mutate(income = as.numeric(income))\n#> Warning: There was 1 warning in `mutate()`.\n#> ℹ In argument: `income = as.numeric(income)`.\n#> Caused by warning:\n#> ! NAs durch Umwandlung erzeugt\n#> # A tibble: 10 × 4\n#>    name           age nationality   income\n#>    <chr>        <dbl> <chr>          <dbl>\n#>  1 Anna Maria      33 DE              1689\n#>  2 Ben             NA <NA>             875\n#>  3 Clara           21 International     NA\n#>  4 Dimitri         28 EU              2299\n#>  5 Emilia-Luise    29 DE              2522\n#>  6 Fatima          23 DE              1060\n#>  7 Gerda           32 DE              1781\n#>  8 Hannah          23 EU              2463\n#>  9 Ismail          27 International   1442\n#> 10 Johanna         21 DE              1404\n```\n:::\n\n\nUm dies zu vermeiden, nutzen wir die `tidyverse`-Funktion `parse_number()`, die alle nicht-numerischen Zeichen entfernt und die Zahlen extrahiert:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nearnings <- earnings |>\n  mutate(income = parse_number(income))\nearnings\n#> # A tibble: 10 × 4\n#>    name           age nationality   income\n#>    <chr>        <dbl> <chr>          <dbl>\n#>  1 Anna Maria      33 DE              1689\n#>  2 Ben             NA <NA>             875\n#>  3 Clara           21 International   2000\n#>  4 Dimitri         28 EU              2299\n#>  5 Emilia-Luise    29 DE              2522\n#>  6 Fatima          23 DE              1060\n#>  7 Gerda           32 DE              1781\n#>  8 Hannah          23 EU              2463\n#>  9 Ismail          27 International   1442\n#> 10 Johanna         21 DE              1404\n```\n:::\n\n",
    "supporting": [
      "daten_import_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}