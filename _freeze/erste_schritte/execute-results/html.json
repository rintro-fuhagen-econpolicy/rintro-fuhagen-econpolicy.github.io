{
  "hash": "b9a3206347d7e2a543128a423aa15b75",
  "result": {
    "engine": "knitr",
    "markdown": "# Erste Schritte in R {#sec-erste_schritte}\n\n\n::: {.cell}\n\n:::\n\n\n## Installation\n\nFür die Teilnahme an diesem Kurs müssen zwei Programme auf dem Computer installiert sein: R und RStudio. R stellt die eigentliche Programmiersprache bereit, während RStudio als integrierte Entwicklungsumgebung (IDE) dient. Zwar lässt sich R auch ohne RStudio nutzen, die Arbeit in RStudio ist jedoch deutlich komfortabler und übersichtlicher.\n\nSollte man bereits Erfahrung mit dem Programmieren haben und regelmäßig mit verschiedenen Sprachen arbeiten, könnten alternativ auch andere IDEs interessant sein, die den Wechsel zwischen Sprachen erleichtern. Beispiele hierfür sind [Visual Studio Code](https://code.visualstudio.com/) oder [Positron](https://positron.posit.co/).\n\n### R installieren\n\n1.  Rufe die Website <https://cran.r-project.org/> auf\n2.  Wähle dein Betriebssystem (Windows, Mac, Linux)\n3.  Lade die neueste Version herunter\n4.  Starte die Installation und folge den Anweisungen\n\nR wird regelmäßig weiterentwickelt und erhält häufig Updates. Daher sollte die installierte Version gelegentlich aktualisiert werden. Insbesondere größere Versionssprünge können etwas aufwendiger sein, da bereits installierte Packages anschließend erneut installiert werden müssen. Detaillierte Hinweise zum Aktualisieren von R stellt der Helpdesk der FernUniversität Hagen [hier](https://wiki.fernuni-hagen.de/helpdesk/Wie_aktualisiere_ich_R%3F) zur Verfügung.\n\n### RStudio installieren\n\n1.  Rufe die Website <https://posit.co/download/rstudio-desktop/> auf\n2.  Lade RStudio Desktop (kostenlose Version) herunter\n3.  Starte die Installation und folge den Anweisungen\n\nSobald eine neue Version von RStudio verfügbar ist, erscheint beim Start des Programms ein entsprechender Hinweis. Die Aktualisierung kann direkt durchgeführt werden, indem man den angezeigten Schritten folgst.\n\n::: callout-warning\n#### Wichtig!\n\nInstalliere zuerst R und danach RStudio, da RStudio auf eine vorhandene R-Installation angewiesen ist.\n:::\n\n## Das RStudio-Interface\n\nÖffnen wir nun RStudio. Das Interface besteht dabei aus den folgenden Elementen (siehe @fig-rstudio-interface):\n\n-   *Konsole* (A): Hier können wir unseren Code ausführen und der korrespondierende Output wird angezeigt. In diesem Beispiel wurde etwa 1+1 addiert sowie der Vektor `x` definiert und angezeigt.\n-   *Environment* (B): Zeigt gespeicherte Objekte. Hier findet sich der in der Konsole definierte Vektor `x` wieder.\n-   *Files/Plot/Help* (C): Hier finden wir unter anderem einen Databrowser (Files), deine erstellten Grafiken (Plots) und die Hilfefunktion (Help)\n-   *Menüleiste* (D)\n\n\n::: {.cell}\n::: {.cell-output-display}\n![RStudio Interface.\n](images/rstudio_interface.png){#fig-rstudio-interface fig-alt='RStudio Interface mit Highlights auf Konsole, Environment, Files/Plot Panels sowie Menüleiste.'}\n:::\n:::\n\n\n## Erste Befehle\n\n### R als Taschenrechner\n\nLass uns als erstes R als Taschenrechner verwenden, um die Handhabung der Konsole kennenzulernen. Um R als Taschenrechner zu nutzen, geben wir einfach die gewünschte Operation ein und drückst <kbd>Enter</kbd>, um den Code auszuführen. Der Befehl (auch Prompt genannt) wird in der Konsole angeführt. Das Ergebnis der Operation wird in der nächsten Zeile angeführt. Beispielsweise kann man in R Zahlen addieren, potenzieren oder logarithmieren:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n10 + 4\n#> [1] 14\n2^3\n#> [1] 8\nlog(4)\n#> [1] 1.386294\n```\n:::\n\n\n::: {.callout-note}\n#### Hinweis\n\nUm ganze Codeblöcke in diesem Kurs kopieren zu können, wird der Output in den Blöcken auskommentiert und folgt einem `#>`. In der eigenen Konsole wird der Output ohne `#>` angezeigt. Die Addition sieht in der Konsole nach der Befehlausführung etwa so aus:\n```         \n> 10 + 4\n[1] 14\n```\n:::\n\n### Kommentare\n\nUm später nachvollziehen zu können, was in unserem Code passiert, können wir Kommentare in deinem Code hinterlassen. Kommentare beginnen mit `#` und werden von R ignoriert:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Division\n10 / 5  # Kommentare können auch am Ende einer Zeile stehen\n#> [1] 2\n```\n:::\n\n\n### Funktionen verwenden\n\nFür komplexere Operationen bietet R eine große Sammlung an Funktionen. Die Ausführung einer Funktion folgt immer dem folgenden Aufbau:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction_name(argument1 = value1, argument2 = value2, ...)\n```\n:::\n\n\nWeiter oben haben wir bereits unsere erste Funktion ausgeführt, um den natürlichen Logarithmus von 4 zu berechen (`log(4)`). Um das Ausführen von Funktionen besser kennen zu lernen, sehen wir uns die Funktion `seq()` an, mit welcher wir Sequenzen von Zahlen erstellen können. Um die Funktion aufzurufen, tippen wir `seq` in die Konsole ein. Ab dem dritten Buchstaben öffnet sich in R ein Pop-Up-Fenster mit möglichen Optionen. Hier kann man entweder mit den Pfeiltasten rauf- oder runtergehen, die gewünschte Funktion wählen und <kbd>Enter</kbd> drücken.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Auswählen der seq()-Funktion.\n](images/seq_function.gif){#fig-seq-fct fig-alt='Auswählen der seq()-Funktion über das Pop-Up-Menü in der Konsole.'}\n:::\n:::\n\n\nWir können auch den gesamten Befehl selbst eingeben und die Klammer öffnen: `seq()`.\n\nUm mehr über die Funktion zu erfahren, können wir einen der folgenden Befehle ausführen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?seq\nhelp(seq)\n```\n:::\n\n\n\nAlternativ drücken wir <kbd>F1</kbd> während wir `seq()` im Pop-Up Menü ausgewählt haben, oder wir gehen gehen direkt zum Help-Fenster und geben *seq* in die Suchfunktion ein. Im Help-Fenster (Panel C in @fig-rstudio-interface) erhalten wir dann eine ausführliche Erklärung der Funktion.\n\nDie R-Dokumentation gibt Aufschluss über die wesentlichen Argumente dieser Funktion. Wir erfahren, dass wir mit `from = ...` den Startwert und mit `to = ...` den Endwert der Zahlsequenz spezifizieren. Über das Argument `by = ...` definieren wir wiederum die Inkremente der Sequenz. Auch können wir die Default-Einstellungen der Funktion ableiten: Diese ist für `from`, `to` und `by` gleich 1.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Help: R-Dokumentation zu seq().\n](images/seq_help.png){#fig-seq-help fig-alt='Help-Fenster der R-Dokumentation zu seq() mit Fokus auf die Helpauswahl, das Suchfenster, sowie die Argumente from, to, und by.'}\n:::\n:::\n\n\nUm eine Sequenz von 1 bis 10 in Einserschritten zu erstellen, führen wir den folgenden Befehl aus:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 10)\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n\n\nDa wir Einserschritte wollen und die Default-Option for `by = ...`  gleich 1 ist, brauchen wir dieses Argument nicht spezifizieren. Ist uns eine Funktion gut bekannt, können wir auch die Bezeichnungen der jeweiligen Argumente ignorieren. R interpretiert den Befehl dann so, als würde jeder Wert für das in dieser Reihenfolge vorgesehene Argument stehen. Um etwa eine Sequenz von 1 bis 10 in Zweierschritten zu erstellen, können wir also auch schreiben:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(1, 10, 2)\n#> [1] 1 3 5 7 9\n```\n:::\n\n\n## Objekte\n\n### Objekte erstellen\n\nUm Daten zu speichern, zu organisieren und wiederzuverwenden können diese in R als Objekt gespeichert werden. In R speichern wir Werte in Objekten mit dem Zuweisungsoperator `<-`. Die Zuweisungslogik folgt dabei immer der Form `objekt_name <- element`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumber <- 3\n```\n:::\n\n\nMit `c()` können wir mehrere Elemente zu einem Objekt hinzufügen, wobei die einzelne Elemente mit einem Komma getrennt werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1, 2, 3, 4, 5)\n```\n:::\n\n\nDie beiden Objekte werden nun im Environment (Panel B in @fig-rstudio-interface) angeführt. Beim definieren eines Objekts wird dieses nicht automatisch in der Konsole angezeigt. Um uns das Objekt `zahlen` anzusehen, können wir einfach den Objektnamen in der Konsole eingeben und den Befehl ausführen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers\n#> [1] 1 2 3 4 5\n```\n:::\n\n\n::: {.callout-tip}\n#### Objektnamen\n\nObjektnamen müssen mit einem Buchstaben beginnen. Erlaubte Zeichen sind Buchstaben, Ziffern, Unterstriche (`_`) und Punkte (`.`). Vermeide Umlaute und andere Sonderzeichen. Objekte sollten aussagekräftig sein und einer gleichbleibenden Namensgebungslogik folgen. Eine weitverbreitete Namensgebungslogik ist *snake_case*, wobei einzelne Worte in Kleinbuchstaben mit Unterstrichen getrennt werden, z.b. `age_students` oder `income_students`. Damit Objektnamen nicht allzu lang werden, verwenden wir Abkürzungen, die auch später nachvollziehbar bleiben, etwa `age_std` oder `inc_std`.\n:::\n\nObjekte können überschrieben werden, in dem ein oder mehrere Elemente demselben Objektnamen überwiesen werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(6.5, 7, 8.3, 9, 10)\n```\n:::\n\n\n::: {.callout-warning}\n#### Fehler bei Objektadressierung\n\nUm Objekte zu addressieren, muss dieses ohne Fehler aufgerufen werden. Tippfehler oder unvollständige Objektnamen führen zu Error-Meldungen. R ist dabei case-sensitiv:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumers\n#> Fehler: Objekt 'numers' nicht gefunden\nNumbers\n#> Fehler: Objekt 'Numbers' nicht gefunden\n```\n:::\n\n:::\n\n### Datentypen\n\nIn R gibt es verschiedene grundlegende Datentypen, die sogenannten atomic types, die die Bausteine für alle anderen Objekte bilden. Der Typ *numeric* wird für Zahlen verwendet. Unsere oben definierten Objekte `number` und `numbers` haben diesen Typ. Ein Sonderfall ist hierbei der Typ *integer*, welcher nur Zahlen aus dem Set der ganzen Zahlen (also keine Dezimalstellen) speichert. Möchten wir explizit Zahlen explizit als *integer* Objekt abspeichern, muss entweder ein *L* an jede Zahl angehängt werden oder die Funktion `as.integer()` verwendet werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers_int <- c(2L, 3L)\nnumbers_int <- as.integer(c(2, 3)) # identer Befehl\nnumbers_int\n#> [1] 2 3\n```\n:::\n\n\nIn den allermeisten Fällen ist eine Definition als *integer* Typ nicht notwendig und somit der Typ *numeric* präferierbar.\n\nDer Typ logical speichert Wahrheitswerte, also `TRUE` oder `FALSE`, und wird häufig für Bedingungen, Filter oder logische Vergleiche eingesetzt. Wenn wir zum Beispiel prüfen wollen, ob die jeweiligen Elemente in `numbers` größer als 7 sind, entsteht ein *logical*-Objekt:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers_greater7 <- numbers > 7\nnumbers_greater7\n#> [1] FALSE FALSE  TRUE  TRUE  TRUE\n```\n:::\n\n\n*Character*-Objekte enthalten Text:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(\"Anna\", \"Ben\", \"Clara\")\nnames\n#> [1] \"Anna\"  \"Ben\"   \"Clara\"\n```\n:::\n\n\nUm R mitzuteilen, dass es sich um Text handelt, verwenden wir Anfühungszeichen, da sonst nach einem Objekt mit diesem Namen gesucht wird:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- c(Anna, Ben, Clara)\n#> Fehler: Objekt 'Anna' nicht gefunden\n```\n:::\n\n\nWeitere häufig verwendete Datentypen in R sind der `factor`-Typ für kategoriale Variablen oder der `date`-Typ für Datum- und Zeitangaben.\n\nUm zu sehen, welchen Typ ein bestimmtes Objekt hat, verwenden wir `class()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(numbers)\n#> [1] \"numeric\"\nclass(numbers_int)\n#> [1] \"integer\"\nclass(numbers_greater7)\n#> [1] \"logical\"\nclass(names)\n#> [1] \"character\"\n```\n:::\n\n\n### Objekttypen\n\nElemente mit einem bestimmten Datentyp bilden die Bausteine für komplexere Objekte. Diese lassen sich je nach Inhalt wieder in unterschiedliche Typen unterteilen. @tbl-obj-types gibt eine Übersicht über die wichtigsten Objekttypen in R.\n\n\n::: {#tbl-obj-types .cell tbl-cap='Objekttypen in R (Auswahl)'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Objekttyp </th>\n   <th style=\"text-align:left;\"> Beschreibung </th>\n   <th style=\"text-align:left;\"> Datentyp-Regel </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Vektor </td>\n   <td style=\"text-align:left;\"> Eindimensionale Sammlung von Elementen </td>\n   <td style=\"text-align:left;\"> Alle Elemente gleicher Datentyp </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Matrix </td>\n   <td style=\"text-align:left;\"> Zweidimensionale Datenstruktur (Zeilen × Spalten) </td>\n   <td style=\"text-align:left;\"> Alle Elemente gleicher Datentyp </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Dataframe </td>\n   <td style=\"text-align:left;\"> Tabellenartige Struktur mit Spalten </td>\n   <td style=\"text-align:left;\"> Spalten können unterschiedliche Datentypen haben </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Tibble </td>\n   <td style=\"text-align:left;\"> Moderne Variante des Dataframes (tidyverse) </td>\n   <td style=\"text-align:left;\"> Wie Dataframe, aber keine automatische Typumwandlung </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Liste </td>\n   <td style=\"text-align:left;\"> Flexible Sammlung von Objekten </td>\n   <td style=\"text-align:left;\"> Beliebige Datentypen kombinierbar </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nDen Objekttyp *Vektor* haben wir bereits kennengelernt. Ein Vektor ist eine eindimensionale Sammlung an Elementen desselben Datentyps. Das Objekt `numbers` ist etwa ein Vektor bestehend aus numerischen Elementen.\n\nEine *Matrix* ist wiederum ein zweidimensionales Objekt aus Elementen desselben Datentyps:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_by_two <- matrix(data = c(1, 2, 3, 4),\n                        nrow = 2, ncol = 2)\ntwo_by_two\n#>      [,1] [,2]\n#> [1,]    1    3\n#> [2,]    2    4\nthree_by_two <- matrix(data = c(1, 2, 3, 4, 5, 6),\n                       nrow = 3, ncol = 2)\nthree_by_two\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\n```\n:::\n\n\nDie Beschränkung auf den gleichen Datentyp bei Matrizen ist häufig zu restriktiv für einen mehrdimensionalen Datensatz. Datensätze werden daher in R meistens als *Dataframe* gespeichert. Ein Dataframe ist ebenfalls zweidimensional, erlaubt aber, dass die jeweiligen Spalten einen unterschiedlichen Datentyp haben. So können wir uns beispielsweise einen Datensatz mit der Funktion `data.frame()` erstellen, der als Variablen in seinen Spalten Namen als `character`, Alter als `integer`, und Noten als `numeric` abspeichert:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- data.frame(\n  name = c(\"Anna\", \"Ben\", \"Clara\"),\n  age = c(22L, 25, 23L),\n  grade = c(1.7, 2.3, 4.0)\n)\nstudents\n#>    name age grade\n#> 1  Anna  22   1.7\n#> 2   Ben  25   2.3\n#> 3 Clara  23   4.0\n```\n:::\n\n\nDataframes eignen sich daher gut für Datenanalysen. Eine modernere (aber in den meisten Eigenschaften idente) Version des Dataframes ist ein *Tibble*.\n\nEine Liste ist die flexibelste Struktur und kann verschiedene Objekte, also Vektoren, Matrizen, Dataframes oder sogar andere Listen, zusammenfassen. Wir können damit zum Beispiel sowohl den Vektor `numbers`, die Matrix `three_by_two` und den Dataframe `students` in einem Objekt abspeichern:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_all <- list(\n  numbers,\n  three_by_two,\n  students\n)\nlist_all\n#> [[1]]\n#> [1]  6.5  7.0  8.3  9.0 10.0\n#> \n#> [[2]]\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\n#> \n#> [[3]]\n#>    name age grade\n#> 1  Anna  22   1.7\n#> 2   Ben  25   2.3\n#> 3 Clara  23   4.0\n```\n:::\n\n\n### Indizierung von Objekten\n\nÜber Indizierung können wir uns einzelne Elemente von Objekten anzeigen lassen und in weitere Folge auch mit diesen Arbeiten. Die Position eines oder mehrere Elemente wird dabei in eckigen Klammern `objekt[]` angegeben. Bei Vektoren ist die Indizierung aufgrund der Eindimensionalität des Objekts einfach:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers\n#> [1]  6.5  7.0  8.3  9.0 10.0\nnumbers[2] # zweites Element im Vektor numbers\n#> [1] 7\nnumbers[c(1, 4)] # erstes und viertes Element\n#> [1] 6.5 9.0\nnumbers[2:4] # zweites bis viertes Element\n#> [1] 7.0 8.3 9.0\nnumbers[-3] # numbers Vektor ohne drittes Element\n#> [1]  6.5  7.0  9.0 10.0\n```\n:::\n\n\nBei zweidimensionalen Objekten (Matrizen und Dataframes) erfolgt die Indizierung nach dem Prinzip `objekt[zeile, spalte]` angegeben. Wollen wir z.B. nur auf die Spalte indizieren, aber alle Zeilen behalten, lassen wir die erste Index-Option frei (`objekt[,spalte]`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthree_by_two[2, 2] # Element in Zeile 2, Spalte 2\n#> [1] 5\nthree_by_two[1,] # alle Elemente der ersten Zeile\n#> [1] 1 4\nthree_by_two[c(1,3), 2] # erste und dritte Zeile in der zweiten Spalte\n#> [1] 4 6\n```\n:::\n\n\nBei Dataframes können wir auf Spalten auch mit dem `$`-Operator indizieren: `dataframe$varname` ist also ident zu `dataframe[,spalte]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents$name\n#> [1] \"Anna\"  \"Ben\"   \"Clara\"\nstudents[,1]\n#> [1] \"Anna\"  \"Ben\"   \"Clara\"\nstudents$age[2]\n#> [1] 25\nstudents[2,2]\n#> [1] 25\n```\n:::\n\n\nIn einer Liste abgespeicherte Objekte werden mit `liste[[index]]` aufgerufen. Das erste Objekt in `liste_alles` finden wir somit über:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlist_all[[1]]\n#> [1]  6.5  7.0  8.3  9.0 10.0\n```\n:::\n\n\n### Arbeiten mit Objekten\n\nWir können Operationen auch mit ganzen Objekte oder indizierten Subsets ausführen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers*2 # Mulipliziert alle Elemente\n#> [1] 13.0 14.0 16.6 18.0 20.0\nmax(numbers) # Maximum im Vektor numbers\n#> [1] 10\nmean(students$age) # Durchschnittsalter der Studierenden\n#> [1] 23.33333\nnrow(students) # Anzahl der Zeilen im students dataframe\n#> [1] 3\n```\n:::\n\n\n### Entfernen von Objekten\n\nObjekte, die nicht mehr gebraucht werden, können mit `rm()` (`remove()`) wieder aus dem Environment gelöscht werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(two_by_two)\nrm(numbers_int, numbers_greater7) # mehrere Objekte können gleichzeitig gelöscht werden\n```\n:::\n\n\nUm sämtliche Objekte auf einmal auf dem Environment zu löschen, können wir folgenden Befehl ausführen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list = ls())\n```\n:::\n\n\nDie Funktion `ls()` gibt dabei die Namen aller im Environment gespeicherter Objekte wieder.\n\n\n\n## Packages\n\nDie bisher verwendeten Funktionen sind allesamt in der Core-Version von R enthalten, welche wir zu Beginn installiert haben (Base R). In R werden zusätzliche Funktionen und Datensätze über Packages bereitgestellt, die die Grundfunktionen der Sprache erweitern. Jedes Package bündelt thematisch verwandte Werkzeuge, wie zum Beispiel Statistikfunktionen, Visualisierungen oder Datenmanipulation. Für diesen Kurs werden wir vor allem auf das Package `tidyverse` zurückgreifen, eine Sammlung von R-Packages, die gemeinsam eine konsistente und leicht verständliche Syntax für Datenaufbereitung und Visualisierung bereitstellen.\n\nDie Installation eines Packages erfolgt über die Funktion `install.packages()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nDie Installation eines Packages ist nur einmal notwendig. Bei jeder Sitzung muss jedoch das gewünschte Package über `library()` geladen werden, um auf die darin enthaltenen Funktionen zugreifen zu können:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n#> ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.2.0     ✔ readr     2.1.6\n#> ✔ forcats   1.0.1     ✔ stringr   1.6.0\n#> ✔ ggplot2   4.0.2     ✔ tibble    3.3.1\n#> ✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n#> ✔ purrr     1.2.1     \n#> ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter()     masks stats::filter()\n#> ✖ dplyr::group_rows() masks kableExtra::group_rows()\n#> ✖ dplyr::lag()        masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n\nAlternativ können wir auch auf Funktionen aus einem bereits installierten aber nicht geladenen Package zugreifen, in dem wir vor der Funktion auf das Package verweisen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackage_name::fct_name(argument1 = value1, argument2 = value2, ...)\n```\n:::\n\n\nDie folgenden Pakete werden wir im Laufe des Kurses ebenfalls verwenden und können daher gleich jetzt installiert werden:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\n  c(\n    \"readxl\", \"writexl\", # Import/Export von Excel-Spreadsheets\n    \"haven\", \"labelled\", # Import/Export von dta-Dateien\n    \"janitor\" # Data Cleaning\n    )\n)\n```\n:::\n\n\n\n\n\n\n",
    "supporting": [
      "erste_schritte_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}