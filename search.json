[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in R",
    "section": "",
    "text": "Willkommen\nWillkommen zum Kurs Einführung in R! Dieser Kurs bietet eine praxisorientierte Einführung in die Programmiersprache R mit Fokus auf Datenanalyse und Statistik. Wir werden lernen, wie man:",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "index.html#aufbau-des-kurses",
    "href": "index.html#aufbau-des-kurses",
    "title": "Einführung in R",
    "section": "Aufbau des Kurses",
    "text": "Aufbau des Kurses\nDer Kurs ist in folgende Teile gegliedert:\n\nGrundlagen: Installation, erste Schritte, Best Practices\nDatenaufbereitung: Daten importieren, aufbereiten und exportieren\nVisualisierung: Grafiken erstellen\nStatistik in R: Deskriptive Statistiken und Regressionsmodelle\nExport von Ergebnissen: Export von Grafiken und Tabellen\nWeitere Themen: Loops, Funktionen und KI-Unterstützung\n\n\n\n\n\n\n\nHinweisWichtig\n\n\n\nDieser Kurs ist derzeit noch Work-in-Progress. Übungsaufgaben zu den einzelnen Kapiteln werden erst in naher Zukunft hinzugefügt.",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "index.html#kontakt-und-feedback",
    "href": "index.html#kontakt-und-feedback",
    "title": "Einführung in R",
    "section": "Kontakt und Feedback",
    "text": "Kontakt und Feedback\n[Hier könnte dein Kontakt oder Feedback-Link stehen]",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "index.html#weitere-literatur",
    "href": "index.html#weitere-literatur",
    "title": "Einführung in R",
    "section": "Weitere Literatur",
    "text": "Weitere Literatur\n\nR for Data Science (2e) von Hadley Wickham et al.\nggplot\nStatistik\nCausal Inf",
    "crumbs": [
      "Willkommen"
    ]
  },
  {
    "objectID": "erste_schritte.html",
    "href": "erste_schritte.html",
    "title": "1  Erste Schritte in R",
    "section": "",
    "text": "1.1 Installation\nFür die Teilnahme an diesem Kurs müssen zwei Programme auf dem Computer installiert sein: R und RStudio. R stellt die eigentliche Programmiersprache bereit, während RStudio als integrierte Entwicklungsumgebung (IDE) dient. Zwar lässt sich R auch ohne RStudio nutzen, die Arbeit in RStudio ist jedoch deutlich komfortabler und übersichtlicher.\nSollte man bereits Erfahrung mit dem Programmieren haben und regelmäßig mit verschiedenen Sprachen arbeiten, könnten alternativ auch andere IDEs interessant sein, die den Wechsel zwischen Sprachen erleichtern. Beispiele hierfür sind Visual Studio Code oder Positron.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "erste_schritte.html#installation",
    "href": "erste_schritte.html#installation",
    "title": "1  Erste Schritte in R",
    "section": "",
    "text": "1.1.1 R installieren\n\nRufe die Website https://cran.r-project.org/ auf\nWähle dein Betriebssystem (Windows, Mac, Linux)\nLade die neueste Version herunter\nStarte die Installation und folge den Anweisungen\n\nR wird regelmäßig weiterentwickelt und erhält häufig Updates. Daher sollte die installierte Version gelegentlich aktualisiert werden. Insbesondere größere Versionssprünge können etwas aufwendiger sein, da bereits installierte Packages anschließend erneut installiert werden müssen. Detaillierte Hinweise zum Aktualisieren von R stellt der Helpdesk der FernUniversität Hagen hier zur Verfügung.\n\n1.1.2 RStudio installieren\n\nRufe die Website https://posit.co/download/rstudio-desktop/ auf\nLade RStudio Desktop (kostenlose Version) herunter\nStarte die Installation und folge den Anweisungen\n\nSobald eine neue Version von RStudio verfügbar ist, erscheint beim Start des Programms ein entsprechender Hinweis. Die Aktualisierung kann direkt durchgeführt werden, indem man den angezeigten Schritten folgst.\n\n\n\n\n\n\nWarnungWichtig!\n\n\n\nInstalliere zuerst R und danach RStudio, da RStudio auf eine vorhandene R-Installation angewiesen ist.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "erste_schritte.html#das-rstudio-interface",
    "href": "erste_schritte.html#das-rstudio-interface",
    "title": "1  Erste Schritte in R",
    "section": "\n1.2 Das RStudio-Interface",
    "text": "1.2 Das RStudio-Interface\nÖffnen wir nun RStudio. Das Interface besteht dabei aus den folgenden Elementen (siehe Abbildung 1.1):\n\n\nKonsole (A): Hier können wir unseren Code ausführen und der korrespondierende Output wird angezeigt. In diesem Beispiel wurde etwa 1+1 addiert sowie der Vektor x definiert und angezeigt.\n\nEnvironment (B): Zeigt gespeicherte Objekte. Hier findet sich der in der Konsole definierte Vektor x wieder.\n\nFiles/Plot/Help (C): Hier finden wir unter anderem einen Databrowser (Files), deine erstellten Grafiken (Plots) und die Hilfefunktion (Help)\n\nMenüleiste (D)\n\n\n\n\n\n\n\n\nAbbildung 1.1: RStudio Interface.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "erste_schritte.html#erste-befehle",
    "href": "erste_schritte.html#erste-befehle",
    "title": "1  Erste Schritte in R",
    "section": "\n1.3 Erste Befehle",
    "text": "1.3 Erste Befehle\n\n1.3.1 R als Taschenrechner\nLass uns als erstes R als Taschenrechner verwenden, um die Handhabung der Konsole kennenzulernen. Um R als Taschenrechner zu nutzen, geben wir einfach die gewünschte Operation ein und drückst Enter, um den Code auszuführen. Der Befehl (auch Prompt genannt) wird in der Konsole angeführt. Das Ergebnis der Operation wird in der nächsten Zeile angeführt. Beispielsweise kann man in R Zahlen addieren, potenzieren oder logarithmieren:\n\n10 + 4\n#&gt; [1] 14\n2^3\n#&gt; [1] 8\nlog(4)\n#&gt; [1] 1.386294\n\n\n\n\n\n\n\nHinweisHinweis\n\n\n\nUm ganze Codeblöcke in diesem Kurs kopieren zu können, wird der Output in den Blöcken auskommentiert und folgt einem #&gt;. In der eigenen Konsole wird der Output ohne #&gt; angezeigt. Die Addition sieht in der Konsole nach der Befehlausführung etwa so aus:\n&gt; 10 + 4\n[1] 14\n\n\n\n1.3.2 Kommentare\nUm später nachvollziehen zu können, was in unserem Code passiert, können wir Kommentare in deinem Code hinterlassen. Kommentare beginnen mit # und werden von R ignoriert:\n\n# Division\n10 / 5  # Kommentare können auch am Ende einer Zeile stehen\n#&gt; [1] 2\n\n\n1.3.3 Funktionen verwenden\nFür komplexere Operationen bietet R eine große Sammlung an Funktionen. Die Ausführung einer Funktion folgt immer dem folgenden Aufbau:\n\nfunction_name(argument1 = value1, argument2 = value2, ...)\n\nWeiter oben haben wir bereits unsere erste Funktion ausgeführt, um den natürlichen Logarithmus von 4 zu berechen (log(4)). Um das Ausführen von Funktionen besser kennen zu lernen, sehen wir uns die Funktion seq() an, mit welcher wir Sequenzen von Zahlen erstellen können. Um die Funktion aufzurufen, tippen wir seq in die Konsole ein. Ab dem dritten Buchstaben öffnet sich in R ein Pop-Up-Fenster mit möglichen Optionen. Hier kann man entweder mit den Pfeiltasten rauf- oder runtergehen, die gewünschte Funktion wählen und Enter drücken.\n\n\n\n\n\n\n\nAbbildung 1.2: Auswählen der seq()-Funktion.\n\n\n\n\nWir können auch den gesamten Befehl selbst eingeben und die Klammer öffnen: seq().\nUm mehr über die Funktion zu erfahren, können wir einen der folgenden Befehle ausführen:\n\n?seq\nhelp(seq)\n\nAlternativ drücken wir F1 während wir seq() im Pop-Up Menü ausgewählt haben, oder wir gehen gehen direkt zum Help-Fenster und geben seq in die Suchfunktion ein. Im Help-Fenster (Panel C in Abbildung 1.1) erhalten wir dann eine ausführliche Erklärung der Funktion.\nDie R-Dokumentation gibt Aufschluss über die wesentlichen Argumente dieser Funktion. Wir erfahren, dass wir mit from = ... den Startwert und mit to = ... den Endwert der Zahlsequenz spezifizieren. Über das Argument by = ... definieren wir wiederum die Inkremente der Sequenz. Auch können wir die Default-Einstellungen der Funktion ableiten: Diese ist für from, to und by gleich 1.\n\n\n\n\n\n\n\nAbbildung 1.3: Help: R-Dokumentation zu seq().\n\n\n\n\nUm eine Sequenz von 1 bis 10 in Einserschritten zu erstellen, führen wir den folgenden Befehl aus:\n\nseq(from = 1, to = 10)\n#&gt;  [1]  1  2  3  4  5  6  7  8  9 10\n\nDa wir Einserschritte wollen und die Default-Option for by = ... gleich 1 ist, brauchen wir dieses Argument nicht spezifizieren. Ist uns eine Funktion gut bekannt, können wir auch die Bezeichnungen der jeweiligen Argumente ignorieren. R interpretiert den Befehl dann so, als würde jeder Wert für das in dieser Reihenfolge vorgesehene Argument stehen. Um etwa eine Sequenz von 1 bis 10 in Zweierschritten zu erstellen, können wir also auch schreiben:\n\nseq(1, 10, 2)\n#&gt; [1] 1 3 5 7 9",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "erste_schritte.html#objekte",
    "href": "erste_schritte.html#objekte",
    "title": "1  Erste Schritte in R",
    "section": "\n1.4 Objekte",
    "text": "1.4 Objekte\n\n1.4.1 Objekte erstellen\nUm Daten zu speichern, zu organisieren und wiederzuverwenden können diese in R als Objekt gespeichert werden. In R speichern wir Werte in Objekten mit dem Zuweisungsoperator &lt;-. Die Zuweisungslogik folgt dabei immer der Form objekt_name &lt;- element:\n\nnumber &lt;- 3\n\nMit c() können wir mehrere Elemente zu einem Objekt hinzufügen, wobei die einzelne Elemente mit einem Komma getrennt werden:\n\nnumbers &lt;- c(1, 2, 3, 4, 5)\n\nDie beiden Objekte werden nun im Environment (Panel B in Abbildung 1.1) angeführt. Beim definieren eines Objekts wird dieses nicht automatisch in der Konsole angezeigt. Um uns das Objekt zahlen anzusehen, können wir einfach den Objektnamen in der Konsole eingeben und den Befehl ausführen:\n\nnumbers\n#&gt; [1] 1 2 3 4 5\n\n\n\n\n\n\n\nTippObjektnamen\n\n\n\nObjektnamen müssen mit einem Buchstaben beginnen. Erlaubte Zeichen sind Buchstaben, Ziffern, Unterstriche (_) und Punkte (.). Vermeide Umlaute und andere Sonderzeichen. Objekte sollten aussagekräftig sein und einer gleichbleibenden Namensgebungslogik folgen. Eine weitverbreitete Namensgebungslogik ist snake_case, wobei einzelne Worte in Kleinbuchstaben mit Unterstrichen getrennt werden, z.b. age_students oder income_students. Damit Objektnamen nicht allzu lang werden, verwenden wir Abkürzungen, die auch später nachvollziehbar bleiben, etwa age_std oder inc_std.\n\n\nObjekte können überschrieben werden, in dem ein oder mehrere Elemente demselben Objektnamen überwiesen werden:\n\nnumbers &lt;- c(6.5, 7, 8.3, 9, 10)\n\n\n\n\n\n\n\nWarnungFehler bei Objektadressierung\n\n\n\nUm Objekte zu addressieren, muss dieses ohne Fehler aufgerufen werden. Tippfehler oder unvollständige Objektnamen führen zu Error-Meldungen. R ist dabei case-sensitiv:\n\nnumers\n#&gt; Fehler: Objekt 'numers' nicht gefunden\nNumbers\n#&gt; Fehler: Objekt 'Numbers' nicht gefunden\n\n\n\n\n1.4.2 Datentypen\nIn R gibt es verschiedene grundlegende Datentypen, die sogenannten atomic types, die die Bausteine für alle anderen Objekte bilden. Der Typ numeric wird für Zahlen verwendet. Unsere oben definierten Objekte number und numbers haben diesen Typ. Ein Sonderfall ist hierbei der Typ integer, welcher nur Zahlen aus dem Set der ganzen Zahlen (also keine Dezimalstellen) speichert. Möchten wir explizit Zahlen explizit als integer Objekt abspeichern, muss entweder ein L an jede Zahl angehängt werden oder die Funktion as.integer() verwendet werden:\n\nnumbers_int &lt;- c(2L, 3L)\nnumbers_int &lt;- as.integer(c(2, 3)) # identer Befehl\nnumbers_int\n#&gt; [1] 2 3\n\nIn den allermeisten Fällen ist eine Definition als integer Typ nicht notwendig und somit der Typ numeric präferierbar.\nDer Typ logical speichert Wahrheitswerte, also TRUE oder FALSE, und wird häufig für Bedingungen, Filter oder logische Vergleiche eingesetzt. Wenn wir zum Beispiel prüfen wollen, ob die jeweiligen Elemente in numbers größer als 7 sind, entsteht ein logical-Objekt:\n\nnumbers_greater7 &lt;- numbers &gt; 7\nnumbers_greater7\n#&gt; [1] FALSE FALSE  TRUE  TRUE  TRUE\n\nCharacter-Objekte enthalten Text:\n\nnames &lt;- c(\"Anna\", \"Ben\", \"Clara\")\nnames\n#&gt; [1] \"Anna\"  \"Ben\"   \"Clara\"\n\nUm R mitzuteilen, dass es sich um Text handelt, verwenden wir Anfühungszeichen, da sonst nach einem Objekt mit diesem Namen gesucht wird:\n\nnames &lt;- c(Anna, Ben, Clara)\n#&gt; Fehler: Objekt 'Anna' nicht gefunden\n\nWeitere häufig verwendete Datentypen in R sind der factor-Typ für kategoriale Variablen oder der date-Typ für Datum- und Zeitangaben.\nUm zu sehen, welchen Typ ein bestimmtes Objekt hat, verwenden wir class():\n\nclass(numbers)\n#&gt; [1] \"numeric\"\nclass(numbers_int)\n#&gt; [1] \"integer\"\nclass(numbers_greater7)\n#&gt; [1] \"logical\"\nclass(names)\n#&gt; [1] \"character\"\n\n\n1.4.3 Objekttypen\nElemente mit einem bestimmten Datentyp bilden die Bausteine für komplexere Objekte. Diese lassen sich je nach Inhalt wieder in unterschiedliche Typen unterteilen. Tabelle 1.1 gibt eine Übersicht über die wichtigsten Objekttypen in R.\n\n\n\nTabelle 1.1: Objekttypen in R (Auswahl)\n\n\n\n\nObjekttyp\nBeschreibung\nDatentyp-Regel\n\n\n\nVektor\nEindimensionale Sammlung von Elementen\nAlle Elemente gleicher Datentyp\n\n\nMatrix\nZweidimensionale Datenstruktur (Zeilen × Spalten)\nAlle Elemente gleicher Datentyp\n\n\nDataframe\nTabellenartige Struktur mit Spalten\nSpalten können unterschiedliche Datentypen haben\n\n\nTibble\nModerne Variante des Dataframes (tidyverse)\nWie Dataframe, aber keine automatische Typumwandlung\n\n\nListe\nFlexible Sammlung von Objekten\nBeliebige Datentypen kombinierbar\n\n\n\n\n\n\n\n\nDen Objekttyp Vektor haben wir bereits kennengelernt. Ein Vektor ist eine eindimensionale Sammlung an Elementen desselben Datentyps. Das Objekt numbers ist etwa ein Vektor bestehend aus numerischen Elementen.\nEine Matrix ist wiederum ein zweidimensionales Objekt aus Elementen desselben Datentyps:\n\ntwo_by_two &lt;- matrix(data = c(1, 2, 3, 4),\n                        nrow = 2, ncol = 2)\ntwo_by_two\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    3\n#&gt; [2,]    2    4\nthree_by_two &lt;- matrix(data = c(1, 2, 3, 4, 5, 6),\n                       nrow = 3, ncol = 2)\nthree_by_two\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n\nDie Beschränkung auf den gleichen Datentyp bei Matrizen ist häufig zu restriktiv für einen mehrdimensionalen Datensatz. Datensätze werden daher in R meistens als Dataframe gespeichert. Ein Dataframe ist ebenfalls zweidimensional, erlaubt aber, dass die jeweiligen Spalten einen unterschiedlichen Datentyp haben. So können wir uns beispielsweise einen Datensatz mit der Funktion data.frame() erstellen, der als Variablen in seinen Spalten Namen als character, Alter als integer, und Noten als numeric abspeichert:\n\nstudents &lt;- data.frame(\n  name = c(\"Anna\", \"Ben\", \"Clara\"),\n  age = c(22L, 25, 23L),\n  grade = c(1.7, 2.3, 4.0)\n)\nstudents\n#&gt;    name age grade\n#&gt; 1  Anna  22   1.7\n#&gt; 2   Ben  25   2.3\n#&gt; 3 Clara  23   4.0\n\nDataframes eignen sich daher gut für Datenanalysen. Eine modernere (aber in den meisten Eigenschaften idente) Version des Dataframes ist ein Tibble.\nEine Liste ist die flexibelste Struktur und kann verschiedene Objekte, also Vektoren, Matrizen, Dataframes oder sogar andere Listen, zusammenfassen. Wir können damit zum Beispiel sowohl den Vektor numbers, die Matrix three_by_two und den Dataframe students in einem Objekt abspeichern:\n\nlist_all &lt;- list(\n  numbers,\n  three_by_two,\n  students\n)\nlist_all\n#&gt; [[1]]\n#&gt; [1]  6.5  7.0  8.3  9.0 10.0\n#&gt; \n#&gt; [[2]]\n#&gt;      [,1] [,2]\n#&gt; [1,]    1    4\n#&gt; [2,]    2    5\n#&gt; [3,]    3    6\n#&gt; \n#&gt; [[3]]\n#&gt;    name age grade\n#&gt; 1  Anna  22   1.7\n#&gt; 2   Ben  25   2.3\n#&gt; 3 Clara  23   4.0\n\n\n1.4.4 Indizierung von Objekten\nÜber Indizierung können wir uns einzelne Elemente von Objekten anzeigen lassen und in weitere Folge auch mit diesen Arbeiten. Die Position eines oder mehrere Elemente wird dabei in eckigen Klammern objekt[] angegeben. Bei Vektoren ist die Indizierung aufgrund der Eindimensionalität des Objekts einfach:\n\nnumbers\n#&gt; [1]  6.5  7.0  8.3  9.0 10.0\nnumbers[2] # zweites Element im Vektor numbers\n#&gt; [1] 7\nnumbers[c(1, 4)] # erstes und viertes Element\n#&gt; [1] 6.5 9.0\nnumbers[2:4] # zweites bis viertes Element\n#&gt; [1] 7.0 8.3 9.0\nnumbers[-3] # numbers Vektor ohne drittes Element\n#&gt; [1]  6.5  7.0  9.0 10.0\n\nBei zweidimensionalen Objekten (Matrizen und Dataframes) erfolgt die Indizierung nach dem Prinzip objekt[zeile, spalte] angegeben. Wollen wir z.B. nur auf die Spalte indizieren, aber alle Zeilen behalten, lassen wir die erste Index-Option frei (objekt[,spalte]):\n\nthree_by_two[2, 2] # Element in Zeile 2, Spalte 2\n#&gt; [1] 5\nthree_by_two[1,] # alle Elemente der ersten Zeile\n#&gt; [1] 1 4\nthree_by_two[c(1,3), 2] # erste und dritte Zeile in der zweiten Spalte\n#&gt; [1] 4 6\n\nBei Dataframes können wir auf Spalten auch mit dem $-Operator indizieren: dataframe$varname ist also ident zu dataframe[,spalte]:\n\nstudents$name\n#&gt; [1] \"Anna\"  \"Ben\"   \"Clara\"\nstudents[,1]\n#&gt; [1] \"Anna\"  \"Ben\"   \"Clara\"\nstudents$age[2]\n#&gt; [1] 25\nstudents[2,2]\n#&gt; [1] 25\n\nIn einer Liste abgespeicherte Objekte werden mit liste[[index]] aufgerufen. Das erste Objekt in liste_alles finden wir somit über:\n\nlist_all[[1]]\n#&gt; [1]  6.5  7.0  8.3  9.0 10.0\n\n\n1.4.5 Arbeiten mit Objekten\nWir können Operationen auch mit ganzen Objekte oder indizierten Subsets ausführen:\n\nnumbers*2 # Mulipliziert alle Elemente\n#&gt; [1] 13.0 14.0 16.6 18.0 20.0\nmax(numbers) # Maximum im Vektor numbers\n#&gt; [1] 10\nmean(students$age) # Durchschnittsalter der Studierenden\n#&gt; [1] 23.33333\nnrow(students) # Anzahl der Zeilen im students dataframe\n#&gt; [1] 3\n\n\n1.4.6 Entfernen von Objekten\nObjekte, die nicht mehr gebraucht werden, können mit rm() (remove()) wieder aus dem Environment gelöscht werden:\n\nrm(two_by_two)\nrm(numbers_int, numbers_greater7) # mehrere Objekte können gleichzeitig gelöscht werden\n\nUm sämtliche Objekte auf einmal auf dem Environment zu löschen, können wir folgenden Befehl ausführen:\n\nrm(list = ls())\n\nDie Funktion ls() gibt dabei die Namen aller im Environment gespeicherter Objekte wieder.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "erste_schritte.html#packages",
    "href": "erste_schritte.html#packages",
    "title": "1  Erste Schritte in R",
    "section": "\n1.5 Packages",
    "text": "1.5 Packages\nDie bisher verwendeten Funktionen sind allesamt in der Core-Version von R enthalten, welche wir zu Beginn installiert haben (Base R). In R werden zusätzliche Funktionen und Datensätze über Packages bereitgestellt, die die Grundfunktionen der Sprache erweitern. Jedes Package bündelt thematisch verwandte Werkzeuge, wie zum Beispiel Statistikfunktionen, Visualisierungen oder Datenmanipulation. Für diesen Kurs werden wir vor allem auf das Package tidyverse zurückgreifen, eine Sammlung von R-Packages, die gemeinsam eine konsistente und leicht verständliche Syntax für Datenaufbereitung und Visualisierung bereitstellen.\nDie Installation eines Packages erfolgt über die Funktion install.packages():\n\ninstall.packages(\"tidyverse\")\n\nDie Installation eines Packages ist nur einmal notwendig. Bei jeder Sitzung muss jedoch das gewünschte Package über library() geladen werden, um auf die darin enthaltenen Funktionen zugreifen zu können:\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.2.0     ✔ readr     2.1.6\n#&gt; ✔ forcats   1.0.1     ✔ stringr   1.6.0\n#&gt; ✔ ggplot2   4.0.2     ✔ tibble    3.3.1\n#&gt; ✔ lubridate 1.9.5     ✔ tidyr     1.3.2\n#&gt; ✔ purrr     1.2.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter()     masks stats::filter()\n#&gt; ✖ dplyr::group_rows() masks kableExtra::group_rows()\n#&gt; ✖ dplyr::lag()        masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nAlternativ können wir auch auf Funktionen aus einem bereits installierten aber nicht geladenen Package zugreifen, in dem wir vor der Funktion auf das Package verweisen:\n\npackage_name::fct_name(argument1 = value1, argument2 = value2, ...)\n\nDie folgenden Pakete werden wir im Laufe des Kurses ebenfalls verwenden und können daher gleich jetzt installiert werden:\n\ninstall.packages(\n  c(\n    \"readxl\", \"writexl\", # Import/Export von Excel-Spreadsheets\n    \"haven\", \"labelled\", # Import/Export von dta-Dateien\n    \"janitor\" # Data Cleaning\n    )\n)",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Erste Schritte in R</span>"
    ]
  },
  {
    "objectID": "best_practices.html",
    "href": "best_practices.html",
    "title": "2  Best Practices",
    "section": "",
    "text": "2.1 R-Scripts\nBisher haben wir unseren Code immer direkt in der Konsole geschrieben und dort ausgeführt. Das ist für erste Schritte praktisch, aber der Code geht leicht verloren und lässt sich nur schwer nachvollziehen oder erneut verwenden. Die Verwendung eines R-Scripts erlaubt uns, Code dauerhaft zu speichern, zu dokumentieren und später reproduzierbar erneut auszuführen. Außerdem lassen sich Scripts strukturieren, kommentieren und leichter mit anderen teilen. Dadurch wird die Arbeit nachvollziehbarer, effizienter und weniger fehleranfällig.\nUm ein R-Script zu öffnen, klicke auf den New File Button oben links in RStudio (rot hervorgehoben in Abbildung 2.1). Dadurch öffnet sich ein zusätzliches Panel im Interface (gelb markiert). Wir können nun unseren Code in diesem Text-Editor schreiben, kommentieren und ausführen. Nachdem wir das R-Script speichern, können wir zu einem späteren Zeitpunkt unseren Code leicht reproduzieren und fortsetzen.\nAbbildung 2.1: RStudio Interface mit R-Script.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Best Practices</span>"
    ]
  },
  {
    "objectID": "best_practices.html#r-scripts",
    "href": "best_practices.html#r-scripts",
    "title": "2  Best Practices",
    "section": "",
    "text": "2.1.1 Ausführen von Befehlen im R-Script\nDa ein R-Script ein Text-Editor ist, wird durch Enter nicht mehr der Befehl ausgeführt (wie in der Konsole), sondern eine neue Zeile eingefügt. Um einen Prompt auszuführen, drücken wir stattdessen gleichzeitig Strg + Enter (oder cmd + Enter bei einem Apple-Gerät). R führt immer den vollständigen Prompt aus, unabhängig davon, an welcher Stelle in der Zeile der Maus-Cursor steht. Um mehrere Code-Zeilen gleichzeitig auszuführen, markiere diese und drücke anschließend Strg + Enter.\n\n2.1.2 Aufbau eines guten R-Scripts\nDamit wir auch zu einem späteren Zeitpunkt nachvollziehen können, was in einem Script passiert, ist sinnvoll, einer gewissen Struktur zu folgen. Zu Beginn eines R-Scripts fassen wir als Kommentar kurz den wesentlichen Inhalt zusammen. Um unser Script in Abschnitte zu unterteilen, können wir sectioning comments verwenden (Keyboard-Shortcut: Strg + Shift + R):\n\n# load packages ---------------------------------------------------------------\n\nUm zwischen den Abschnitten zu springen, können wir das Navigations-Dropdown-Menü unten links im R-Script-Editor verwenden (blau markiert in Abbildung 2.1). Ein übersichtliches R-Script ist zum Beispiel so aufgebaut:\n\n# ============================================================================\n# Projekt: Analyse von Studentendaten\n# Script: 01_data_cleaning.R\n# Autor: Dein Name\n# Datum: 2025-10-05\n# Beschreibung: Lädt und bereinigt die Rohdaten\n# ============================================================================\n\n# 1. Pakete laden ----------------------------------------------------------\nlibrary(tidyverse)\nlibrary(readxl)\n\n# 2. Daten einlesen --------------------------------------------------------\nstudents &lt;- read_csv(\"data/raw/students.csv\")\n\n# 3. Daten bereinigen ------------------------------------------------------\nstudents_clean &lt;- students %&gt;%\n  filter(!is.na(age)) %&gt;% # Filtern von Studierenden ohne Altersangabe\n  mutate(grade_numerisch = as.numeric(grade))\n\n# 4. Daten speichern -------------------------------------------------------\nwrite_rds(students_clean, \"data/processed/students_clean.rds\")\n\n\n\n\n\n\n\nTippDo’s und Don’ts für R-Scripts\n\n\n\n\n\nDo’s:\n\nAussagekräftige Kommentare\nLogische Struktur\nEin Script = Eine Arbeitsaufgabe\nPakete am Anfang laden\nSektionen mit # ----\n\n\n\nDon’ts:\n\nAbsolute Pfade verwenden\nZu lange Scripts\nHartcodierte Werte\nFehlende Kommentare",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Best Practices</span>"
    ]
  },
  {
    "objectID": "best_practices.html#working-directories",
    "href": "best_practices.html#working-directories",
    "title": "2  Best Practices",
    "section": "\n2.2 Working Directories",
    "text": "2.2 Working Directories\nDas Working Directory legt den Ordner fest, in dem R standardmäßig nach Dateien sucht und neue Dateien speichert. In RStudio ist das standardmäßig der Dokumenteordner des Systems. Um dein Working Directory zu überprüfen, verwende getwd():\n\ngetwd()\n#&gt; \"C:/Users/fischeneder/Documents\"\n\nDateien, die man ohne vorheriges Setzen eines Working Directory öffnet oder speichert, werden zunächst in diesem Ordner gesucht bzw. abgelegt. Daher ist es sinnvoll, das Working Directory bewusst auf den gewünschten Projektordner zu setzen, um die Arbeit strukturiert, reproduzierbar und unabhängig vom Standardpfad zu gestalten.\nDas Working Directory setzt du mittels mit setwd():\n\nsetwd(\"pfad/zu/deinem/projektordner\")\n\n\n\n\n\n\n\nWarnungRelative Pfade &gt; absolute Pfade\n\n\n\nIn R kannst du Daten aus deinem Dateiexplorer importieren und exportieren. Eine Möglichkeit, auf eine Datei zuzugreifen ist es, den gesamten (=absoluten) Dateipfad zu spezifizieren. Möchtest du beispielsweise eine csv-Datei im Datenordner innerhalb deines Projektordners einlesen:\n\ndataset &lt;- read_csv(\"pfad/zu/deinem/projektordner/daten/dataset.csv\")\n\nEin sinnvoll gewähltes Working Directory beinhaltet alle für dein Script notwendigen Ordner und Dateien. Nach dem Setzen des Working Directorys kannst du auf diese zugreifen, ohne den gesamten (absoluten) Pfad zu spezifizieren:\n\nsetwd(\"pfad/zu/deinem/projektordner\")\ndataset &lt;- read_csv(\"daten/dataset.csv\")\n\nR sucht dabei die gewünschte Datei ausgehend von deinem Working Directory. Das hat den Vorteil, dass du den Projektordner verschieben oder teilen kannst, und nur das Working Directory angepasst werden muss, damit dein Code läuft.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Best Practices</span>"
    ]
  },
  {
    "objectID": "best_practices.html#r-projects",
    "href": "best_practices.html#r-projects",
    "title": "2  Best Practices",
    "section": "\n2.3 R-Projects",
    "text": "2.3 R-Projects\nDas Setzen des Working Directorys verlangt einen absoluten Dateipfad. Dies kann leicht zu Problemen führen, wenn du deinen Projektordner verschiebst oder dein Projekt mit anderen Personen teilst. Die Verwendung eines R-Projects bietet deutliche Vorteile gegenüber dem manuellen Setzen des Working Directorys mit setwd() in einem Script. Ein R-Project legt automatisch das Arbeitsverzeichnis auf den Projektordner fest, wodurch alle Scripts, Daten und Ergebnisse konsistent im gleichen Ordner gesucht und gespeichert werden. Das macht die Arbeit nicht nur übersichtlicher und strukturierter, sondern auch reproduzierbar, da andere Nutzer das Projekt auf ihrem Computer öffnen können, ohne Pfade im Code anpassen zu müssen.\nUm ein R-Project für diesen Einführungskurs zu erstellen, führen wir die Schritte in Abbildung 2.2. Im letzen Schritt geben wir unserem R-Project einen passenden Namen (r_intro) und wählen den Ordner aus, in dem wir das Projekt ablegen wollen. Bei der Erstellung des R-Projects wird dann in diesem Ordner ein neuer Subordner erstellt, der nun automatisch das Working Directory dieses Projects ist. In diesem Ordner legen wir alle für unser Projekt relevanten Dateien ab. Somit ist unser Projekt jederzeit reproduzierbar.\n\n\n\n\n\n\n\nAbbildung 2.2: Erstellung eines neuen R-Projects.\n\n\n\n\nDas aktuell geöffnete R-Project wird im Interface oben rechts über dem Environment-Panel angezeigt (rosa markiert in Abbildung 2.1). Um zwischen R-Projects zu wechseln, können wir auf diesen Button klicken und ein anderes Project auswählen.\n\n\n\n\n\n\nHinweisAbstellen der automatischen Workspace-Speicherung\n\n\n\nIn den Default-Einstellungen speichert RStudio beim Beenden automatisch den aktuellen Workspace und lädt ihn beim nächsten Start wieder. Das hat den Vorteil, dass nicht gespeicherte Objekte weiterhin verfügbar sind und man scheinbar nahtlos weiterarbeiten kann.\nDiese Voreinstellung bringt jedoch auch Risiken mit sich. Zum einen besteht die Gefahr, sich auf die automatische Sicherung zu verlassen und Änderungen an Skripten oder Daten nicht bewusst und regelmäßig zu speichern. Zum anderen kann es – insbesondere bei der Arbeit mit mehreren R-Projects – leicht passieren, dass Analysen im falschen Projekt umzusetzen oder Objekte im falschen Umfeld zu speichern, da standardmäßig das zuletzt geöffnete Project erneut gestartet wird.\nUm diese Probleme zu vermeiden, empfiehlt es sich, die automatische Workspace-Speicherung zu deaktivieren. Die entsprechenden Einstellungen findest du in der Menüleiste unter Tools → Global Options, wo du die in Abbildung 2.3 markierten Optionen anpassen kannst.\n\n\n\n\n\n\n\nAbbildung 2.3: Abstellen der automatischen Workspace-Speicherung.",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Best Practices</span>"
    ]
  },
  {
    "objectID": "best_practices.html#ordnerstruktur-namensgebung-und-code-style",
    "href": "best_practices.html#ordnerstruktur-namensgebung-und-code-style",
    "title": "2  Best Practices",
    "section": "\n2.4 Ordnerstruktur, Namensgebung und Code-Style",
    "text": "2.4 Ordnerstruktur, Namensgebung und Code-Style\nEine gute Ordnerstruktur ist die Grundlage für organisierte Projekte. Nach der Erstellung deines R-Projects solltest du dich um Unterordner für Daten, Scripts und Output kümmern. Deine finale Ordnerstruktur könnte etwa so aussehen:\nmein-projekt/\n├── data/\n│   ├── raw/           # Originaldaten (nie ändern!)\n│   └── processed/     # Bearbeitete Daten\n├── scripts/\n│   ├── 01_daten_laden.R\n│   ├── 02_daten_bereinigen.R\n│   └── 03_analyse.R\n├── output/\n│   ├── figures/       # Grafiken\n│   └── tables/        # Tabellen\n├── docs/              # Dokumentation\n├── mein-projekt.Rproj\n└── README.txt\nAuch deine Dateinamen sollten einer einheitlichen Struktur folgen. Nummeriere deine R-Scripts, damit sie im Ordner in einer sinnvollen Reihenfolge aufscheinen. Benenne Output-Dateien mit einem konstanten Muster (z.B. figure01.png, figure02.png, …).\n\n\n\n\n\n\nTippCode-Style\n\n\n\nEin guter und kohärenter Code-Style ist wichtig, weil er den Code lesbar, verständlich und leichter wartbar macht. Konsistente Einrückungen, sprechende Variablennamen und klare Struktur helfen nicht nur dir selbst, den Überblick zu behalten, sondern auch anderen, die den Code später lesen oder erweitern müssen. Außerdem reduziert ein sauberer Stil die Wahrscheinlichkeit von Fehlern, erleichtert das Debuggen und sorgt dafür, dass Projekte langfristig reproduzierbar und professionell bleiben.\nArbeite dich durch das Kapitel zu Code-Style in R for Data Science durch, um Best Practices zu erlernen!",
    "crumbs": [
      "Grundlagen",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Best Practices</span>"
    ]
  },
  {
    "objectID": "daten_transform.html",
    "href": "daten_transform.html",
    "title": "3  Daten aufbereiten",
    "section": "",
    "text": "3.1 Dplyr\nDatensätze liegen häufig nicht in der Form vor, die für Analyse oder Visualisierung benötigt wird. Daher müssen wir sie meist zunächst aufbereiten. Dazu gehört, relevante Variablen auszuwählen, Beobachtungen zu filtern, Datentypen zu korrigieren, neue Kennzahlen zu berechnen oder Informationen sinnvoll zusammenzufassen. Um diese Schritte zu illustrieren, verwenden wir den Palmer Penguins-Datensatz, der über das Package palmerpenguins frei verfügbar ist:\nDer penguins Datensatz enthält Informationen zu 344 Pinguinen mit den folgenden acht Variablen:\nZur Datenmanipulation verwenden wir das dplyr Package, das Teil von tidyverse ist. In diesem Kapitel lernen wir die wichtigsten dplyr-Funktionen kennen. Für eine ausführliche Einführung siehe Kapitel 3, 5 und 12–19 in R for Data Science. Alle dplyr-Funktionen nehmen einen Datensatz (Data Frame oder Tibble) als erstes Argument, führen die gewünschte Operation aus und geben einen neuen Datensatz zurück. Solltest du das tidyverse noch nicht geladen haben, lade es mit:\nlibrary(tidyverse)",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#dplyr",
    "href": "daten_transform.html#dplyr",
    "title": "3  Daten aufbereiten",
    "section": "",
    "text": "TippPipes\n\n\n\nKomplexe Transformationen erfordern oft, mehrere dplyr-Funktionen zu kombinieren. Beispiel: Wir wollen einen Datensatz erstellen, der nur Pinguine der Insel Biscoe enthält und pro Spezies die durchschnittliche Schnabellänge berechnet:\n\npenguins_final &lt;- filter(penguins, island == \"Biscoe\")\npenguins_final &lt;- group_by(penguins_final, species)\npenguins_final &lt;- summarise(penguins_final, bill_len = mean(bill_len, na.rm = T))\npenguins_final\n#&gt; # A tibble: 2 × 2\n#&gt;   species bill_len\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1 Adelie      39.0\n#&gt; 2 Gentoo      47.5\n\nFür eine besser lesbare Verkettung von Funktionen werden wir in Zukunft Pipes (|&gt;) verwenden. Pipes ermöglichen, dass das Ergebnis eines Ausdrucks direkt an die nächste Funktion übergeben wird, ohne dass man verschachtelte Klammern schreiben muss oder Objekte mehrfach definieren muss.\nEine Pipe übergibt das Ergebnis des linken Ausdrucks automatisch als erstes Argument an die Funktion rechts: x |&gt; f(y) ↔︎ f(x, y) und x |&gt; f(y) |&gt; g(z) ↔︎ g(f(x, y), z). Somit können wir den Code besser lesbar schreiben als:\n\npenguins |&gt;\n  filter(island == \"Biscoe\") |&gt;\n  group_by(species) |&gt;\n  summarize(bill_len = mean(bill_len, na.rm = T))\n#&gt; # A tibble: 2 × 2\n#&gt;   species bill_len\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1 Adelie      39.0\n#&gt; 2 Gentoo      47.5",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#tidy-data-sets",
    "href": "daten_transform.html#tidy-data-sets",
    "title": "3  Daten aufbereiten",
    "section": "\n3.2 Tidy Data Sets",
    "text": "3.2 Tidy Data Sets\nDaten können in unterschiedlicher Struktur dargestellt werden. Für die Arbeit in R eignet sich besonders das tidy data-Format. Es folgt drei Grundregeln: - Jede Variable ist eine Spalte - Jede Beobachtung ist eine Zeile - Jede Zelle enthält genau einen Wert\nDurch diese Struktur wird der Datensatz übersichtlich, leicht zu analysieren und kompatibel mit modernen R-Werkzeugen wie dplyr und ggplot2.\nIn unserem Übungsdatensatz penguins ist jede Zeile ein einzelner Pinguin und in den Spalten erhalten wir Informationen zu bestimmten Variablen (z.B. Spezies oder Geschlecht) für jede dieser Pinguin-Beobachtungen.",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#daten-auswählen-und-sortieren",
    "href": "daten_transform.html#daten-auswählen-und-sortieren",
    "title": "3  Daten aufbereiten",
    "section": "\n3.3 Daten auswählen und sortieren",
    "text": "3.3 Daten auswählen und sortieren\nBevor wir mit Analysen beginnen, müssen wir häufig relevanten Daten auswählen und sortieren, um den Datensatz übersichtlich zu halten. Mit dplyr erledigen wir dies z.B. mit select() zum Auswählen von Variablen, filter() oder slice() zum Filtern von Zeilen, distinct() und drop_na() zum Bereinigen von Duplikaten und fehlenden Werten sowie arrange() zum Sortieren. So können wir gezielt nur die Informationen betrachten, die für die Analyse wichtig sind.\n\n3.3.1 select()\nselect() ermöglicht es uns, nur die gewünschten Spalten eines Datensatzes zu behalten. Benötigen wir etwa nur Informationen zur Spezies, Insel und der Flügellänge können wir diese Variablen auswählen mit:\n\npenguins |&gt;\n  select(species, island, flipper_len)\n#&gt; # A tibble: 344 × 3\n#&gt;   species island    flipper_len\n#&gt;   &lt;fct&gt;   &lt;fct&gt;           &lt;int&gt;\n#&gt; 1 Adelie  Torgersen         181\n#&gt; 2 Adelie  Torgersen         186\n#&gt; 3 Adelie  Torgersen         195\n#&gt; 4 Adelie  Torgersen          NA\n#&gt; 5 Adelie  Torgersen         193\n#&gt; 6 Adelie  Torgersen         190\n#&gt; # ℹ 338 more rows\n\nUm eine Variable zu entfernen, setzen wir ein Minuszeichen davor:\n\npenguins |&gt;\n  select(-island)\n#&gt; # A tibble: 344 × 7\n#&gt;   species bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;      &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie      39.1     18.7         181      3750 male    2007\n#&gt; 2 Adelie      39.5     17.4         186      3800 female  2007\n#&gt; 3 Adelie      40.3     18           195      3250 female  2007\n#&gt; 4 Adelie      NA       NA            NA        NA &lt;NA&gt;    2007\n#&gt; 5 Adelie      36.7     19.3         193      3450 female  2007\n#&gt; 6 Adelie      39.3     20.6         190      3650 male    2007\n#&gt; # ℹ 338 more rows\n\n\n\n\n\n\n\nHinweisHinweis\n\n\n\nDamit der penguins Datensatz nicht immer wieder neu geladen werden muss, speichern wir Transformationen in diesem Kapitel nicht ab. In der eigenen Datenaufbereitung solltest du Änderungen einem Objekt zuweisen, damit diese erhalten bleiben:\n\npenguins &lt;- penguins |&gt;\n  select(-island)\n\n\n\n\n3.3.2 filter()\nMit filter() können wir bestimmte Zeilen eines Datensatzes auswählen, die bestimmte Bedingungen erfüllen. So lassen sich gezielt Beobachtungen extrahieren, etwa alle Pinguine der Art Adelie oder alle Pinguine mit einer Schnabellänge von mindestens 40 Milimetern:\n\npenguins |&gt;\n  filter(species == \"Adelie\")\n#&gt; # A tibble: 152 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n#&gt; 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n#&gt; 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n#&gt; 4 Adelie  Torgersen     NA       NA            NA        NA &lt;NA&gt;    2007\n#&gt; 5 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n#&gt; 6 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n#&gt; # ℹ 146 more rows\npenguins |&gt;\n  filter(bill_len &gt;= 40)\n#&gt; # A tibble: 242 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     40.3     18           195      3250 female  2007\n#&gt; 2 Adelie  Torgersen     42       20.2         190      4250 &lt;NA&gt;    2007\n#&gt; 3 Adelie  Torgersen     41.1     17.6         182      3200 female  2007\n#&gt; 4 Adelie  Torgersen     42.5     20.7         197      4500 male    2007\n#&gt; 5 Adelie  Torgersen     46       21.5         194      4200 male    2007\n#&gt; 6 Adelie  Biscoe        40.6     18.6         183      3550 male    2007\n#&gt; # ℹ 236 more rows\n\n\n\n\n\n\n\nTippLogische Operatoren in R\n\n\n\nViele Schritte in der Datenaufbereitung setzen Kenntniss über logische Operatoren in R voraus. Tabelle 3.2 fasst die wichtigsten zusammen:\n\n\n\nTabelle 3.2: Übersicht: Logische Operatoren in R\n\n\n\n\nOperator\nBedeutung\nBeispiel\n\n\n\n==\ngleich\nspecies == \"Adelie\"\n\n\n!=\nungleich\nspecies != \"Adelie\"\n\n\n&lt;\nkleiner als\nbill_len &lt; 40\n\n\n&gt;\ngrößer als\nbill_len &gt; 40\n\n\n&lt;=\nkleiner oder gleich\nbill_len &lt;= 40\n\n\n&gt;=\ngrößer oder gleich\nbill_len &gt;= 40\n\n\n%in%\nenthalten in\nspecies %in% c(\"Adelie\", \"Gentoo\")\n\n\n!%in%\nnicht enthalten in\nspecies !%in% c(\"Adelie\", \"Gentoo\")\n\n\n&\nlogisches UND\nsex == \"female\" & island == \"Biscoe\"\n\n\n|\nlogisches ODER\nbill_len &gt;= 45 | bill_len &lt;= 35\n\n\n\n\n\n\n\n\n\n\nWollen wir auf mehrere Konditionen gleichzeitig filtern, können wir diese in der Filter-Option angeben. Wir extrahieren weibliche Pinguine auf der Insel Biscoe mit:\n\npenguins |&gt;\n  filter(sex == \"female\" & island == \"Biscoe\")\n#&gt; # A tibble: 80 × 8\n#&gt;   species island bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Biscoe     37.8     18.3         174      3400 female  2007\n#&gt; 2 Adelie  Biscoe     35.9     19.2         189      3800 female  2007\n#&gt; 3 Adelie  Biscoe     35.3     18.9         187      3800 female  2007\n#&gt; 4 Adelie  Biscoe     40.5     17.9         187      3200 female  2007\n#&gt; 5 Adelie  Biscoe     37.9     18.6         172      3150 female  2007\n#&gt; 6 Adelie  Biscoe     39.6     17.7         186      3500 female  2008\n#&gt; # ℹ 74 more rows\n\nDas Subset an Pinguinen, die eine Schnabellänge von mindestens 45mm oder eine Schnabellänge von höchstens 35mm haben filtern wir mit dem Oder-Operator |:\n\npenguins |&gt;\n  filter(bill_len &gt;= 45 | bill_len &lt;= 35)\n#&gt; # A tibble: 177 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     34.1     18.1         193      3475 &lt;NA&gt;    2007\n#&gt; 2 Adelie  Torgersen     34.6     21.1         198      4400 male    2007\n#&gt; 3 Adelie  Torgersen     34.4     18.4         184      3325 female  2007\n#&gt; 4 Adelie  Torgersen     46       21.5         194      4200 male    2007\n#&gt; 5 Adelie  Biscoe        35       17.9         190      3450 female  2008\n#&gt; 6 Adelie  Biscoe        34.5     18.1         187      2900 female  2008\n#&gt; # ℹ 171 more rows\n\nÄquivalent zu den Base R Operatoren & und | sind die dplyr-Funktionen when_all() und when_any():\n\npenguins |&gt;\n  filter(when_all(sex == \"female\", island == \"Biscoe\"))\n#&gt; # A tibble: 80 × 8\n#&gt;   species island bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Biscoe     37.8     18.3         174      3400 female  2007\n#&gt; 2 Adelie  Biscoe     35.9     19.2         189      3800 female  2007\n#&gt; 3 Adelie  Biscoe     35.3     18.9         187      3800 female  2007\n#&gt; 4 Adelie  Biscoe     40.5     17.9         187      3200 female  2007\n#&gt; 5 Adelie  Biscoe     37.9     18.6         172      3150 female  2007\n#&gt; 6 Adelie  Biscoe     39.6     17.7         186      3500 female  2008\n#&gt; # ℹ 74 more rows\npenguins |&gt;\n  filter(when_any(bill_len &gt;= 40, body_mass &gt;= 4000))\n#&gt; # A tibble: 253 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     40.3     18           195      3250 female  2007\n#&gt; 2 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n#&gt; 3 Adelie  Torgersen     42       20.2         190      4250 &lt;NA&gt;    2007\n#&gt; 4 Adelie  Torgersen     41.1     17.6         182      3200 female  2007\n#&gt; 5 Adelie  Torgersen     34.6     21.1         198      4400 male    2007\n#&gt; 6 Adelie  Torgersen     42.5     20.7         197      4500 male    2007\n#&gt; # ℹ 247 more rows\n\n\n\n\n\n\n\nWarnungUmgang mit NAs: filter_out()\n\n\n\nLogische Bedingungen können bei fehlenden Werten ( (NA) Probleme verursachen. Wollen wir etwa alle weiblichen Pinguine aus dem Datensatz entfernen führt penguins |&gt; filter(sex != \"female\") dazu, dass sowohl weibliche Pinguine als auch jene mit fehlender Geschlechtsinformation ausgeschlossen werden.\nMit filter_out() schließen wir nur Beobachtungen aus, auf welche die Kondition zutrifft:\n\npenguins |&gt;\n  filter_out(sex == \"female\")\n#&gt; # A tibble: 179 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex    year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt; &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     39.1     18.7         181      3750 male   2007\n#&gt; 2 Adelie  Torgersen     NA       NA            NA        NA &lt;NA&gt;   2007\n#&gt; 3 Adelie  Torgersen     39.3     20.6         190      3650 male   2007\n#&gt; 4 Adelie  Torgersen     39.2     19.6         195      4675 male   2007\n#&gt; 5 Adelie  Torgersen     34.1     18.1         193      3475 &lt;NA&gt;   2007\n#&gt; 6 Adelie  Torgersen     42       20.2         190      4250 &lt;NA&gt;   2007\n#&gt; # ℹ 173 more rows\n\nDer Datensatz enthält jetzt keine weiblichen Pinguine mehr, aber jene mit fehlenden Werten sind weiterhin enthalten.\n\n\n\n3.3.3 slice()\nManchmal möchten wir nur einen Teil des Datensatzes auswählen, ohne explizit nach bestimmten Werten zu filtern. Das ist besonders praktisch bei großen Datensätzen, wenn wir zunächst nur mit einem Sample arbeiten wollen, um Rechenressourcen zu schonen. Dafür nutzen wir slice(), zum Beispiel um die Zeilen 1, 3 und 6–8 aus dem penguins-Datensatz auszuwählen:\n\npenguins |&gt;\n  slice(1, 3, 6:8)\n#&gt; # A tibble: 5 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n#&gt; 2 Adelie  Torgersen     40.3     18           195      3250 female  2007\n#&gt; 3 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n#&gt; 4 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n#&gt; 5 Adelie  Torgersen     39.2     19.6         195      4675 male    2007\n\nFür slice() steht eine Reihe hilfreicher Varianten zur Verfügung: - slice_head()/slice_tail(): Nimmt die ersten/letzen N Beobachtungen eines Datensatzes (penguins |&gt; slice_head(n = 10)) - slice_min()/slice_max(): Nimmt die N Beobachtungen mit den niedrigsten/höchsten Werten einer Variable (penguins |&gt; slice_min(bill_len, n = 5)) - slice_sample(): Zieht zufällig N Beobachtungen aus dem gesamten Datensatz (penguins |&gt; slice_sample(n = 5)). Für Reproduzierbarkeit sollte zuerst mit set.seed() ein Seed gesetzt werden.\n\n\n\n\n\n\nHinweisslice() mit gruppierten Daten\n\n\n\nHaben wir den Datensatz mit group_by() in Gruppen klassifiziert, so wird die jeweilige slice-Operation auf jede Gruppe separat angewandt:\n\npenguins |&gt;\n  group_by(island) |&gt;\n  slice_max(bill_len, n = 2)\n#&gt; # A tibble: 6 × 8\n#&gt; # Groups:   island [3]\n#&gt;   species   island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;     &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Gentoo    Biscoe        59.6     17           230      6050 male    2007\n#&gt; 2 Gentoo    Biscoe        55.9     17           228      5600 male    2009\n#&gt; 3 Chinstrap Dream         58       17.8         181      3700 female  2007\n#&gt; 4 Chinstrap Dream         55.8     19.8         207      4000 male    2009\n#&gt; 5 Adelie    Torgersen     46       21.5         194      4200 male    2007\n#&gt; 6 Adelie    Torgersen     45.8     18.9         197      4150 male    2008\n\n\n\n\n3.3.4 distinct()\nOft enthält ein Datensatz doppelte Zeilen, die für die Analyse nicht relevant sind. Mit distinct() können wir gezielt nur die einzigartigen Beobachtungen behalten und so Redundanzen entfernen. Zum Beispiel lassen sich im penguins-Datensatz alle verschiedenen Kombinationen aus Spezies und Insel extrahieren:\n\npenguins |&gt;\n  distinct(species, island)\n#&gt; # A tibble: 5 × 2\n#&gt;   species   island   \n#&gt;   &lt;fct&gt;     &lt;fct&gt;    \n#&gt; 1 Adelie    Torgersen\n#&gt; 2 Adelie    Biscoe   \n#&gt; 3 Adelie    Dream    \n#&gt; 4 Gentoo    Biscoe   \n#&gt; 5 Chinstrap Dream\n\nSpezifizieren wir keine Variablen innerhalb von distinct(), so droppen wir alle Duplikate aus dem Datensatz (im penguins Datensatz gibt aber es keine zwei identen Beobachtungen). Mit der Option .keep_all = TRUE behalten wir die Informationen in allen weiteren Variablen für die erste distinkte Beobachtung:\n\npenguins |&gt;\n  distinct(species, island, .keep_all = TRUE)\n#&gt; # A tibble: 5 × 8\n#&gt;   species   island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;     &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie    Torgersen     39.1     18.7         181      3750 male    2007\n#&gt; 2 Adelie    Biscoe        37.8     18.3         174      3400 female  2007\n#&gt; 3 Adelie    Dream         39.5     16.7         178      3250 female  2007\n#&gt; 4 Gentoo    Biscoe        46.1     13.2         211      4500 female  2007\n#&gt; 5 Chinstrap Dream         46.5     17.9         192      3500 female  2007\n\n\n3.3.5 drop_na()\nOft enthalten Datensätze fehlende Werte (NA), die bestimmte Analysen oder Berechnungen stören können. Mit drop_na() können wir gezielt alle Zeilen entfernen, die in ausgewählten Variablen fehlende Werte enthalten, und so einen sauberen Datensatz erhalten. Zum Beispiel lässt sich im penguins-Datensatz nur jene Beobachtungen behalten, bei denen die Schnabeltiefe nicht fehlt:\n\npenguins |&gt;\n  drop_na(bill_dep)\n#&gt; # A tibble: 342 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Torgersen     39.1     18.7         181      3750 male    2007\n#&gt; 2 Adelie  Torgersen     39.5     17.4         186      3800 female  2007\n#&gt; 3 Adelie  Torgersen     40.3     18           195      3250 female  2007\n#&gt; 4 Adelie  Torgersen     36.7     19.3         193      3450 female  2007\n#&gt; 5 Adelie  Torgersen     39.3     20.6         190      3650 male    2007\n#&gt; 6 Adelie  Torgersen     38.9     17.8         181      3625 female  2007\n#&gt; # ℹ 336 more rows\n\nSpezifizieren wir keine Variable innerhalb von drop_na(), so werden sämtliche Beobachtungen mit zumindest einem fehlenden Wert in einer der Variablen ausgeschlossen (penguins |&gt; drop_na()).\n\n\n\n\n\n\nWarnungGefahren beim Entfernen fehlender Werte\n\n\n\nMan sollte mit drop_na() vorsichtig sein, weil beim Entfernen von Zeilen mit fehlenden Werten unter Umständen wichtige Daten verloren gehen. Gerade wenn viele Variablen NA-Werte enthalten, kann das zu einer stark verkleinerten Stichprobe führen und die Analyse verzerren. Deshalb sollte man vorher prüfen, wie viele Werte betroffen sind und überlegen, ob alternative Strategien wie Imputation oder gezieltes Entfernen nur einzelner Spalten sinnvoller sind.\n\n\n\n3.3.6 arrange()\nMit arrange() können wir die Zeilen eines Datensatzes nach einer oder mehreren Variablen sortieren. So lassen sich Daten übersichtlicher darstellen, Extremwerte leicht erkennen oder vorbereitend für weitere Analysen ordnen, ohne den Datensatz inhaltlich zu verändern.\n\npenguins |&gt;\n  arrange(bill_len, bill_dep)\n#&gt; # A tibble: 344 × 8\n#&gt;   species island    bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Adelie  Dream         32.1     15.5         188      3050 female  2009\n#&gt; 2 Adelie  Dream         33.1     16.1         178      2900 female  2008\n#&gt; 3 Adelie  Torgersen     33.5     19           190      3600 female  2008\n#&gt; 4 Adelie  Dream         34       17.1         185      3400 female  2008\n#&gt; 5 Adelie  Torgersen     34.1     18.1         193      3475 &lt;NA&gt;    2007\n#&gt; 6 Adelie  Torgersen     34.4     18.4         184      3325 female  2007\n#&gt; # ℹ 338 more rows\n\nWenn mehr als eine Variable angeführt ist, ordnet arrange() zuerst nach der erstgenannten und nur bei Gleichstand nach den weiteren Variablen. Fehlende Werte werden immer als letztes angeordnet. Per Default ordnet arrange() von unten nach oben. Wollen wir vom Maximum aus sortieren, verwenden wir desc() innerhalb von arrange():\n\npenguins |&gt;\n  arrange(desc(bill_len))\n#&gt; # A tibble: 344 × 8\n#&gt;   species   island bill_len bill_dep flipper_len body_mass sex     year\n#&gt;   &lt;fct&gt;     &lt;fct&gt;     &lt;dbl&gt;    &lt;dbl&gt;       &lt;int&gt;     &lt;int&gt; &lt;fct&gt;  &lt;int&gt;\n#&gt; 1 Gentoo    Biscoe     59.6     17           230      6050 male    2007\n#&gt; 2 Chinstrap Dream      58       17.8         181      3700 female  2007\n#&gt; 3 Gentoo    Biscoe     55.9     17           228      5600 male    2009\n#&gt; 4 Chinstrap Dream      55.8     19.8         207      4000 male    2009\n#&gt; 5 Gentoo    Biscoe     55.1     16           230      5850 male    2009\n#&gt; 6 Gentoo    Biscoe     54.3     15.7         231      5650 male    2008\n#&gt; # ℹ 338 more rows",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#variablen-verändern-und-erstellen",
    "href": "daten_transform.html#variablen-verändern-und-erstellen",
    "title": "3  Daten aufbereiten",
    "section": "\n3.4 Variablen verändern und erstellen",
    "text": "3.4 Variablen verändern und erstellen\n\n3.4.1 mutate()\n\n3.4.2 case_when() & replace_when()\n\n3.4.3 recode_values() & replace_values()",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#gruppieren-und-zusammenfassen",
    "href": "daten_transform.html#gruppieren-und-zusammenfassen",
    "title": "3  Daten aufbereiten",
    "section": "\n3.5 Gruppieren und Zusammenfassen",
    "text": "3.5 Gruppieren und Zusammenfassen\n\n3.5.1 group_by()\n\n3.5.2 summarize()\n\n3.5.3 count()",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#datensätzen-verbinden",
    "href": "daten_transform.html#datensätzen-verbinden",
    "title": "3  Daten aufbereiten",
    "section": "\n3.6 Datensätzen verbinden",
    "text": "3.6 Datensätzen verbinden\n\n3.6.1 bind_rows() & bind_cols()\n\n3.6.2 inner_join(), left_join(), full_join()",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#datensatz-umformen",
    "href": "daten_transform.html#datensatz-umformen",
    "title": "3  Daten aufbereiten",
    "section": "\n3.7 Datensatz umformen",
    "text": "3.7 Datensatz umformen\n\n3.7.1 pivot_longer()\n\n3.7.2 pivot_wider()",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_transform.html#weitere-themen",
    "href": "daten_transform.html#weitere-themen",
    "title": "3  Daten aufbereiten",
    "section": "\n3.8 Weitere Themen",
    "text": "3.8 Weitere Themen\n\n3.8.1 Strings und Regular Expressions\n\n3.8.2 Datum und Zeit\n\n3.8.3 Fehlende Werte",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Daten aufbereiten</span>"
    ]
  },
  {
    "objectID": "daten_import.html",
    "href": "daten_import.html",
    "title": "4  Daten importieren",
    "section": "",
    "text": "4.1 Datenformate\nBisher haben wir Objekte in R selbst erstellt oder in R Packages enthaltene Datensätze verwendet. In diesem Abschnitt lernen wir, wie man Datensätze in R importiert. Dazu erstellen wir zuerst in dem Ordner unseres R-Projects einen Datenordner und folgende Unterordner:\nAnschließend laden wir ein Set an unterschiedlichen Datensatz-Arten aus dem Github-Ordner des Kurses in den raw Ordner, in dem wir entweder alle Dateien in diesem Github-Ordner manuell herunterladen, oder den folgenden Code in R ausführen:\nIn der Praxis begegnen dir verschiedene Datenformate, die mit unterschiedlichen Funktionen in R eingelesen werden. Tabelle 4.1 gibt einen Überblick über die gebräuchlichsten Formate.\nTabelle 4.1: Datensatzformate in der Praxis (Auswahl)\n\n\n\n\nDateiformat\nTypisch für\nPackage\nLesefunktion\n\n\n\ncsv\nAllgemein\nreadr (tidyverse)\nread_csv()\n\n\nrds\nR\nreadr (tidyverse)\nread_rds()\n\n\ntxt\nAllgemein\nreadr (tidyverse)\nread_delim()\n\n\nxlsx\nMS Office\nreadxl\nread_excel()\n\n\ndta\nStata\nhaven\nread_dta()",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "daten_import.html#daten-einlesen",
    "href": "daten_import.html#daten-einlesen",
    "title": "4  Daten importieren",
    "section": "\n4.2 Daten einlesen",
    "text": "4.2 Daten einlesen\nWir werden zum Datenimport auf Funktionen aus dem readr Package zurückgreifen, welches Teil von tidyverse ist. Solltest du tidyverse noch nicht geladen haben, lade es mit:\n\nlibrary(tidyverse)\n\n\n4.2.1 CSV-Dateien\nDas CSV-Format (Comma-Separated Values) speichert tabellarische Daten als Text, wobei jede Zeile eine Beobachtung und jede Spalte einen Wert enthält, getrennt durch Kommata oder andere Trennzeichen. Beim Import in R müssen wir auf das korrekte Trennzeichen achten, damit die Zahlen korrekt eingelesen werden.\nCSV-Dateien können mit der Funktion read_csv() aus dem tidyverse/readr Package eingelesen werden:\n\nearnings &lt;- read_csv(\"data/raw/earnings_data/earnings.csv\")\nearnings\n#&gt; # A tibble: 10 × 4\n#&gt;   Names        age.in.years Nationalität  `inc in Eur`\n#&gt;   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt; 1 Anna Maria             33 DE            1689        \n#&gt; 2 Ben                    NA N/A           875         \n#&gt; 3 Clara                  21 International 2000€       \n#&gt; 4 Dimitri                28 EU            2299        \n#&gt; 5 Emilia-Luise           29 DE            2522        \n#&gt; 6 Fatima                 23 DE            1060        \n#&gt; # ℹ 4 more rows\n\nInternational werden die einzelnen Spalten mit einem Komma (,) getrennt. Dies ist auch das Default-Trennzeichen bei read_csv(). Da in der deutschen Sprache dieses als Zeichen für Dezimalstellen verwendet wird, wird hier das Semikolon/der Strichpunkt (;) als Trennzeichen verwendet. Verwenden wir das falsche Trennzeichen beim Einlesen von CSV-Dateien mit diesem Trennzeichen, werden die Daten falsch eingelesen:\n\nread_csv(\"data/raw/earnings_data/earnings_de.csv\")\n#&gt; # A tibble: 10 × 1\n#&gt;   `Names;age.in.years;Nationalität;inc in Eur`\n#&gt;   &lt;chr&gt;                                       \n#&gt; 1 Anna Maria;33;DE;1689                       \n#&gt; 2 Ben;NA;N/A;875                              \n#&gt; 3 Clara;21;International;2000€                \n#&gt; 4 Dimitri;28;EU;2299                          \n#&gt; 5 Emilia-Luise;29;DE;2522                     \n#&gt; 6 Fatima;23;DE;1060                           \n#&gt; # ℹ 4 more rows\n\nStattdessen müssen wir bei einer solchen Encodierung read_csv2() verwenden:\n\nread_csv2(\"data/raw/earnings_data/earnings_de.csv\")\n#&gt; # A tibble: 10 × 4\n#&gt;   Names        age.in.years Nationalität  `inc in Eur`\n#&gt;   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt; 1 Anna Maria             33 DE            1689        \n#&gt; 2 Ben                    NA N/A           875         \n#&gt; 3 Clara                  21 International 2000€       \n#&gt; 4 Dimitri                28 EU            2299        \n#&gt; 5 Emilia-Luise           29 DE            2522        \n#&gt; 6 Fatima                 23 DE            1060        \n#&gt; # ℹ 4 more rows\n\n\n\n\n\n\n\nWarnungHäufige Probleme mit CSV-Dateien\n\n\n\n\n\nTrennzeichen: read_csv(\"datei.csv\") bei , als Trennzeichen, read_csv2(\"datei.csv\") bei ;\n\n\nEncoding: Bei Problemen mit Sonderzeichen muss das Encoding spezifiziert werden, etwa read_csv(\"datei.csv\", locale = locale(encoding = \"latin1\"))\n\n\nDezimaltrennzeichen: Ebenfalls über das locale Argument,locale = locale(decimal_mark = \",\")\n\n\nFalsche Spaltentypen: Mit col_types spezifizieren\n\n\n\n\n4.2.2 RDS-Dateien\nRDS ist ein R-spezifisches Format, das ein einzelnes R-Objekt speichert. RDS speichert Objekte in nativer R-Struktur, inklusive Datentypen, Faktoren, Datum/Zeit und sogar komplexer Objekte wie Modelle, wodurch beim Einlesen keine Umwandlungen nötig sind. RDS-Dateien sind oft kleiner und schneller zu lesen als Textdateien, da keine Konvertierung von und zu Text nötig ist.\nWir können RDS-Dateien mit read_rds() einlesen:\n\nearnings &lt;- read_rds(\"data/raw/earnings_data/earnings.rds\")\n\n\n\n\n\n\n\nHinweisRData-Format\n\n\n\nEin weiteres R-spezifisches Format ist RData. RData kann mehrere Objekte speichern:\n\nnumbers &lt;- 6:10\nnames &lt;- c(\"Anna\", \"Ben\", \"Clara\")\nsave(numbers, names, file = \"data/raw/earnings_data/multidata.RData\")\nrm(numbers, names)\n\nMit load() werden alle in dieser Datei abgespeicherten R-Objekte importiert:\n\nload(\"data/raw/earnings_data/multidata.RData\")\n\n\n\n\n4.2.3 Excel-Spreadsheets\nUm Excel-Spreadsheets einzulesen benötigt man in R ein zusätzliches Package (readxl). Mit der Funktion read_excel() können sowohl .xlsx als auch .xls Dateien eingeladen werden.\n\nlibrary(readxl)\nread_excel(\"data/raw/earnings_data/earnings.xlsx\")\n#&gt; # A tibble: 10 × 4\n#&gt;   Names        age.in.years Nationalität  `inc in Eur`\n#&gt;   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt; 1 Anna Maria             33 DE            1689        \n#&gt; 2 Ben                    NA N/A           875         \n#&gt; 3 Clara                  21 International 2000€       \n#&gt; 4 Dimitri                28 EU            2299        \n#&gt; 5 Emilia-Luise           29 DE            2522        \n#&gt; 6 Fatima                 23 DE            1060        \n#&gt; # ℹ 4 more rows\n\nPer Default importiert diese Funktion immer den Datensatz aus dem ersten Tabellenblatt. Mit dem Argument sheet = ... können wir das Tabellenblatt wählen. Möglich ist sowohl, die Nummer des Tabellenblatts als Zahl anzugeben, als auch den Namen des Tabellenblatts in Anführungszeichen anzugeben. Mit dem Argument range = ... können wir außerdem den Bereich des Tabellenblatts angeben, den wir einlesen wollen:\n\nread_excel(\"data/raw/earnings_data/earnings.xlsx\", sheet = 1, range = \"A1:C3\")\n#&gt; # A tibble: 2 × 3\n#&gt;   Names      age.in.years Nationalität\n#&gt;   &lt;chr&gt;             &lt;dbl&gt; &lt;chr&gt;       \n#&gt; 1 Anna Maria           33 DE          \n#&gt; 2 Ben                  NA N/A\n\nUm einen Überblick über die Tabellenblätter eines Spreadsheets zu bekommen, ist die Funktion excel_sheets() im readxl Package hilfreich:\n\nexcel_sheets(\"data/raw/earnings_data/earnings.xlsx\")\n#&gt; [1] \"Sheet1\"\n\n\n4.2.4 Stata-Datensätze\nStata ist eine alternative Statistiksoftware, die in den Wirtschaftswissenschaften immer noch häufig verwendet wird. Für das Speichern von Datensätzen verwendet Stata das .dta-Format. Dieses speichert sowohl die Daten als auch Variablen- und Wertelabels, sodass beim Einlesen in R oder Stata die Struktur, Kategorien und Labels erhalten bleiben.\nFür das Einlesen von Stata-Datensätzen verwenden wir das haven Package und die Funktion ``:\n\nlibrary(haven)\nread_dta(\"data/raw/earnings_data/earnings.dta\")\n#&gt; # A tibble: 10 × 4\n#&gt;   names          age nationality        income\n#&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;dbl+lbl&gt;           &lt;dbl&gt;\n#&gt; 1 Anna Maria      33  1 [DE]              1689\n#&gt; 2 Ben             NA NA                    875\n#&gt; 3 Clara           21  3 [International]   2000\n#&gt; 4 Dimitri         28  2 [EU]              2299\n#&gt; 5 Emilia-Luise    29  1 [DE]              2522\n#&gt; 6 Fatima          23  1 [DE]              1060\n#&gt; # ℹ 4 more rows\n\nIn Stata werden Faktorvariablen wie in diesem Fall nationality numerisch abgespeichert und mit Labels versehen. Um diese in R miteinzulesen, können wir haven::as_factor() verwenden:\n\nread_dta(\"data/raw/earnings_data/earnings.dta\") |&gt;\n  mutate(nationality = as_factor(nationality))\n#&gt; # A tibble: 10 × 4\n#&gt;   names          age nationality   income\n#&gt;   &lt;chr&gt;        &lt;dbl&gt; &lt;fct&gt;          &lt;dbl&gt;\n#&gt; 1 Anna Maria      33 DE              1689\n#&gt; 2 Ben             NA &lt;NA&gt;             875\n#&gt; 3 Clara           21 International   2000\n#&gt; 4 Dimitri         28 EU              2299\n#&gt; 5 Emilia-Luise    29 DE              2522\n#&gt; 6 Fatima          23 DE              1060\n#&gt; # ℹ 4 more rows\n\n\n\n\n\n\n\nTippAutomatisiertes Faktor-Einlesen bei dta\n\n\n\nDamit wir nicht bei jeder Variable im Datensatz überprüfen müssen, ob es sich um eine Label-Variable handelt, können wir auch folgenden Code verwenden, der über alle Variable (across(.)) die Funktion as_factor() anwendet, falls es sich dabei um eine Label-Variable handelt (where(is.labelled)):\n\nread_dta(\"data/raw/earnings_data/earnings.dta\") |&gt;\n  mutate(across(where(is.labelled), as_factor))\n\n\n\n\n4.2.5 Weitere Dateiformate\nDie Funktion read_delim() kann in R verwendet werden, um Datensätze mit beliebigem Trennzeichen einzulesen. Sie versucht dabei, das Trennzeichen automatisch zu erkennen. Wir können damit etwa eine Textdatei (.txt) einlesen:\n\nread_delim(\"data/raw/earnings_data/earnings_tab.txt\")\n#&gt; # A tibble: 10 × 4\n#&gt;   Names        age.in.years Nationalität  `inc in Eur`\n#&gt;   &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt; 1 Anna Maria             33 DE            1689        \n#&gt; 2 Ben                    NA N/A           875         \n#&gt; 3 Clara                  21 International 2000€       \n#&gt; 4 Dimitri                28 EU            2299        \n#&gt; 5 Emilia-Luise           29 DE            2522        \n#&gt; 6 Fatima                 23 DE            1060        \n#&gt; # ℹ 4 more rows\n\nBei diesem Text-File wird der Tabulator als Trennzeichen verwendet und von R auch korrekt beim Einlesen erkannt. Wir können das Trennzeichen aber auch explizit über das delim = value-Argument spezifizieren:\n\nread_delim(\"data/raw/earnings_data/earnings_tab.txt\", delim = \"\\t\")\n\n\n\n\n\n\n\nWarnungProbleme mit Trennzeichen\n\n\n\nBei TXT-Dateien oder anderen allgemeinen Datensätzen kann es jedoch immer wieder zu Problemen kommen, wenn das Trennzeichen auch innerhalb einer Variable verwendet wird. Wurde zum Beispiel ein Datensatz als TXT-Datei mit Leerzeichen als Trennzeichen abgespeichert, so führt dies beim Einlesen zu folgendem Problem:\n\nread_delim(\"data/raw/earnings_data/earnings_space.txt\", delim = \" \")\n#&gt; # A tibble: 10 × 6\n#&gt;   Names        age.in.years Nationalität  inc    `in` Eur  \n#&gt;   &lt;chr&gt;        &lt;chr&gt;        &lt;chr&gt;         &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;\n#&gt; 1 Anna         Maria        33            DE     1689 NA   \n#&gt; 2 Ben          &lt;NA&gt;         N/A           875      NA NA   \n#&gt; 3 Clara        21           International 2000€    NA NA   \n#&gt; 4 Dimitri      28           EU            2299     NA NA   \n#&gt; 5 Emilia-Luise 29           DE            2522     NA NA   \n#&gt; 6 Fatima       23           DE            1060     NA NA   \n#&gt; # ℹ 4 more rows\n\nDa die erste Beobachtung der Namensvariable (Anna Maria) und die Variablenbezeichnung inc in Eur Leerzeichen enthalten, werden hier die Werte in die nächsten Spalten verschoben. Daher ist es ratsam beim Exportieren von eigenen Datensätzen auf Formate zurückzugreifen, die von R problemlos richtig gelesen werden (etwa RDS oder CSV).",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "daten_import.html#daten-ansehen",
    "href": "daten_import.html#daten-ansehen",
    "title": "4  Daten importieren",
    "section": "\n4.3 Daten ansehen",
    "text": "4.3 Daten ansehen\nNach dem Import von Daten sollte man sich den Datensatz immer zunächst genau ansehen, um Struktur, Datentypen und mögliche Probleme frühzeitig zu erkennen. Bisher haben wir uns den Datensatz durch Eingabe des Objektnamens anzeigen lassen. Sollte ein Datensatz als Dataframe und nicht als Tibble geladen sein, hat dies den Nachteil, dass hier der gesamte Datensatz in der Konsole ausgegeben wird. Bei kleinen Datensätzen macht das kaum einen Unterschied, aber bei größeren Daten kann die vollständige Ausgabe sehr unübersichtlich werden und die Konsole „überfluten“.\nEs ist daher besser, sich in der Konsole nur Teile eines Datensatzes anzeigen zu lassen. In Base R bieten sich dafür Funktionen wie head() und tail() (Anzeigen der ersten bzw. letzten Zeilen):\n\nhead(earnings, n = 5)\n#&gt; # A tibble: 5 × 4\n#&gt;   Names        age.in.years Nationalität  `inc in Eur`\n#&gt;   &lt;chr&gt;               &lt;int&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt; 1 Anna Maria             33 DE            1689        \n#&gt; 2 Ben                    NA N/A           875         \n#&gt; 3 Clara                  21 International 2000€       \n#&gt; 4 Dimitri                28 EU            2299        \n#&gt; 5 Emilia-Luise           29 DE            2522\n\nIm tidyverse Package bietet die Funktion glimpse() eine kompakte Übersicht:\n\nglimpse(earnings)\n#&gt; Rows: 10\n#&gt; Columns: 4\n#&gt; $ Names        &lt;chr&gt; \"Anna Maria\", \"Ben\", \"Clara\", \"Dimitri\", \"Emilia-Luise…\n#&gt; $ age.in.years &lt;int&gt; 33, NA, 21, 28, 29, 23, 32, 23, 27, 21\n#&gt; $ Nationalität &lt;chr&gt; \"DE\", \"N/A\", \"International\", \"EU\", \"DE\", \"DE\", \"DE\", …\n#&gt; $ `inc in Eur` &lt;chr&gt; \"1689\", \"875\", \"2000€\", \"2299\", \"2522\", \"1060\", \"1781\"…\n\nNeben den ersten Werten in jeder Variable sehen wir auch, dass unser Datensatz aus 10 Zeilen und 4 Spalten besteht, sowie den Datentyp der jeweiligen Variablen (z.b. character bei earnings$Names).\nUm uns den ganzen Datensatz anzusehen, können wir uns den Datensatz in einem separaten Fenster öffnen. Dies geschieht entweder durch Doppelklick auf den Datensatz im Environment-Fenster oder durch die Funktionen View() (Base R) bzw. view() (tidyverse):\n\nview(earnings)\n\nDadurch öffnet sich im R-Script-Panel ein neues Fenster mit dem Datensatz (Abbildung 4.1). Um uns den Datensatz genauer anzusehen, haben wir auch die Möglichkeit, Daten zu filtern (grüne Markierung), zu suchen (rote Markierung) oder den Datensatz anhand einer bestimmten Variable zu sortieren (blaue Markierung).\n\n\n\n\n\n\n\nAbbildung 4.1: Separates Datensatz-Fenster in R.",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "daten_import.html#daten-bereinigen",
    "href": "daten_import.html#daten-bereinigen",
    "title": "4  Daten importieren",
    "section": "\n4.4 Daten bereinigen",
    "text": "4.4 Daten bereinigen\nNachdem wir einen Datensatz importiert haben müssen wir diesen häufig bereinigen, bevor wir mit der Analyse oder Weiterverarbeitung starten. Wesentliche Punkte sind dabei die Vereinheitlichung der Variablennamen, eine Korrektur falscher Datentypen und die Identifizierung fehlender Werte.\nDurch einen ersten Blick auf die Daten bekommen wir schnell einen Überblick, welche Probleme im Datensatz bestehen:\n\n#&gt; # A tibble: 10 × 4\n#&gt;    Names        age.in.years Nationalität  `inc in Eur`\n#&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt;  1 Anna Maria             33 DE            1689        \n#&gt;  2 Ben                    NA N/A           875         \n#&gt;  3 Clara                  21 International 2000€       \n#&gt;  4 Dimitri                28 EU            2299        \n#&gt;  5 Emilia-Luise           29 DE            2522        \n#&gt;  6 Fatima                 23 DE            1060        \n#&gt;  7 Gerda                  32 DE            1781        \n#&gt;  8 Hannah                 23 EU            2463        \n#&gt;  9 Ismail                 27 International 1442        \n#&gt; 10 Johanna                21 DE            1404\n\nDer earnings-Datensatz zeigt dabei mehrere typische Probleme: - Fehlende Werte: In der Variable Nationalität wurde ein fehlender Wert nicht als NA erkannt, sondern als Text eingelesen (N/A). - Variablennamen: Die Namen sind uneinheitlich und enthalten Großbuchstaben, Sonderzeichen, Leerzeichen oder Punkte – sie widersprechen damit den Best Practices zur Namensgebung. - Datentypen: Die Variable incEur wurde als character eingelesen, sollte aber eigentlich numerisch sein.\nDiese Probleme können wir mit den in Kapitel 3 vorgestellten Operationen lösen. Es ist jedoch sinnvoll, den Einleseprozess so anzupassen, dass die Daten direkt korrekt eingelesen werden.\n\n4.4.1 Fehlende Werte\nR interpretiert beim CSV-Import standardmäßig nur leere Felder oder den String NA als fehlende Werte (NA). In unserem Datensatz fehlt jedoch auch die zweite Beobachtung in Nationalität, die als N/A codiert wurde. Mit read_csv() können wir über das Argument na = ... festlegen, welche Werte als NA eingelesen werden sollen:\n\nearnings &lt;- read_csv(\"data/raw/earnings_data/earnings.csv\", na = c(\"\", \"NA\", \"N/A\"))\nearnings\n#&gt; # A tibble: 10 × 4\n#&gt;    Names        age.in.years Nationalität  `inc in Eur`\n#&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       \n#&gt;  1 Anna Maria             33 DE            1689        \n#&gt;  2 Ben                    NA &lt;NA&gt;          875         \n#&gt;  3 Clara                  21 International 2000€       \n#&gt;  4 Dimitri                28 EU            2299        \n#&gt;  5 Emilia-Luise           29 DE            2522        \n#&gt;  6 Fatima                 23 DE            1060        \n#&gt;  7 Gerda                  32 DE            1781        \n#&gt;  8 Hannah                 23 EU            2463        \n#&gt;  9 Ismail                 27 International 1442        \n#&gt; 10 Johanna                21 DE            1404\n\n\n4.4.2 Variablennamen\nVariablen sollten – wie alle R-Objekte – aussagekräftig und einheitlich benannt werden. In diesem Kurs orientieren wir uns dabei an der snake_case-Konvention. Die ursprünglichen Variablennamen widersprechen dieser Logik, da sie Großbuchstaben, Sonderzeichen, Leerzeichen oder Punkte als Trennzeichen enthalten. Außerdem transportieren manche Namen zu viele Informationen: Dass das Alter in Jahren oder das Einkommen in Euro gemessen wird, ist in der Regel aus dem Kontext des Datensatzes klar und somit redundant.\nUm Variablennamen gezielt zu ändern, können wir rename(new_name = old_name) verwenden. Enthält ein Variablenname Leerzeichen, muss er in Backticks (`) gesetzt werden:\n\nearnings &lt;- earnings |&gt;\n  rename(\n    name = Names,\n    age = age.in.years,\n    nationality = Nationalität,\n    income = `inc in Eur`\n  )\nearnings\n#&gt; # A tibble: 10 × 4\n#&gt;    name           age nationality   income\n#&gt;    &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt; \n#&gt;  1 Anna Maria      33 DE            1689  \n#&gt;  2 Ben             NA &lt;NA&gt;          875   \n#&gt;  3 Clara           21 International 2000€ \n#&gt;  4 Dimitri         28 EU            2299  \n#&gt;  5 Emilia-Luise    29 DE            2522  \n#&gt;  6 Fatima          23 DE            1060  \n#&gt;  7 Gerda           32 DE            1781  \n#&gt;  8 Hannah          23 EU            2463  \n#&gt;  9 Ismail          27 International 1442  \n#&gt; 10 Johanna         21 DE            1404\n\nBei Datensätzen mit vielen Variablen ist eine einzelne Umbenennung mühsam. Hier kann die Funktion janitor::clean_names() (aus dem gleichnamigen Paket) helfen, alle Variablennamen automatisch in snake_case zu übersetzen. Einzelne Anpassungen lassen sich anschließend bei Bedarf noch vornehmen:\n\nread_csv(\"data/raw/earnings_data/earnings.csv\", na = c(\"\", \"NA\", \"N/A\")) |&gt;\n  janitor::clean_names(case = \"snake\")\n#&gt; # A tibble: 10 × 4\n#&gt;    names        age_in_years nationalitat  inc_in_eur\n#&gt;    &lt;chr&gt;               &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;     \n#&gt;  1 Anna Maria             33 DE            1689      \n#&gt;  2 Ben                    NA &lt;NA&gt;          875       \n#&gt;  3 Clara                  21 International 2000€     \n#&gt;  4 Dimitri                28 EU            2299      \n#&gt;  5 Emilia-Luise           29 DE            2522      \n#&gt;  6 Fatima                 23 DE            1060      \n#&gt;  7 Gerda                  32 DE            1781      \n#&gt;  8 Hannah                 23 EU            2463      \n#&gt;  9 Ismail                 27 International 1442      \n#&gt; 10 Johanna                21 DE            1404\n\n\n4.4.3 Datentypen\nWenn Variablen im Originaldatensatz nicht sauber codiert sind, kann R sie im falschen Typ einlesen. In unserem Beispiel wurde das Einkommen bei der dritten Beobachtung mit einem Euro-Zeichen versehen, sodass R die Variable als character interpretiert. Eine direkte Umwandlung mit as.numeric() würde diese Beobachtung in NA recodieren, da sie keinen reinen Zahlenwert enthält:\n\nearnings |&gt;\n  mutate(income = as.numeric(income))\n#&gt; Warning: There was 1 warning in `mutate()`.\n#&gt; ℹ In argument: `income = as.numeric(income)`.\n#&gt; Caused by warning:\n#&gt; ! NAs introduced by coercion\n#&gt; # A tibble: 10 × 4\n#&gt;    name           age nationality   income\n#&gt;    &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;\n#&gt;  1 Anna Maria      33 DE              1689\n#&gt;  2 Ben             NA &lt;NA&gt;             875\n#&gt;  3 Clara           21 International     NA\n#&gt;  4 Dimitri         28 EU              2299\n#&gt;  5 Emilia-Luise    29 DE              2522\n#&gt;  6 Fatima          23 DE              1060\n#&gt;  7 Gerda           32 DE              1781\n#&gt;  8 Hannah          23 EU              2463\n#&gt;  9 Ismail          27 International   1442\n#&gt; 10 Johanna         21 DE              1404\n\nUm dies zu vermeiden, nutzen wir die tidyverse-Funktion parse_number(), die alle nicht-numerischen Zeichen entfernt und die Zahlen extrahiert:\n\nearnings &lt;- earnings |&gt;\n  mutate(income = parse_number(income))\nearnings\n#&gt; # A tibble: 10 × 4\n#&gt;    name           age nationality   income\n#&gt;    &lt;chr&gt;        &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;\n#&gt;  1 Anna Maria      33 DE              1689\n#&gt;  2 Ben             NA &lt;NA&gt;             875\n#&gt;  3 Clara           21 International   2000\n#&gt;  4 Dimitri         28 EU              2299\n#&gt;  5 Emilia-Luise    29 DE              2522\n#&gt;  6 Fatima          23 DE              1060\n#&gt;  7 Gerda           32 DE              1781\n#&gt;  8 Hannah          23 EU              2463\n#&gt;  9 Ismail          27 International   1442\n#&gt; 10 Johanna         21 DE              1404",
    "crumbs": [
      "Datenaufbereitung",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Daten importieren</span>"
    ]
  },
  {
    "objectID": "referenzen.html",
    "href": "referenzen.html",
    "title": "Literatur & Ressourcen",
    "section": "",
    "text": "Bücher",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#bücher",
    "href": "referenzen.html#bücher",
    "title": "Literatur & Ressourcen",
    "section": "",
    "text": "R for Data Science (2e)\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2nd ed.). O’Reilly Media.\nhttps://r4ds.hadley.nz/\nDas Standardwerk für Data Science mit R. Kostenlos online verfügbar.\n\n\nggplot2: Elegant Graphics for Data Analysis\nWickham, H. (2016). ggplot2: Elegant Graphics for Data Analysis (3rd ed.). Springer.\nhttps://ggplot2-book.org/\n\n\nAdvanced R\nWickham, H. (2019). Advanced R (2nd ed.). Chapman and Hall/CRC.\nhttps://adv-r.hadley.nz/",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#online-kurse",
    "href": "referenzen.html#online-kurse",
    "title": "Literatur & Ressourcen",
    "section": "Online-Kurse",
    "text": "Online-Kurse\n\nRStudio Education\nhttps://education.rstudio.com/\nKostenlose Tutorials und Kurse von RStudio.\n\n\nDataCamp\nhttps://www.datacamp.com/\nInteraktive R-Kurse (teilweise kostenpflichtig).\n\n\nCoursera: R Programming\nhttps://www.coursera.org/\nVerschiedene R-Kurse von Universitäten.",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#cheat-sheets",
    "href": "referenzen.html#cheat-sheets",
    "title": "Literatur & Ressourcen",
    "section": "Cheat Sheets",
    "text": "Cheat Sheets\n\nRStudio Cheat Sheets\n\ndplyr\nggplot2\ntidyr\nR Markdown\nund viele mehr",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#hilfreiche-websites",
    "href": "referenzen.html#hilfreiche-websites",
    "title": "Literatur & Ressourcen",
    "section": "Hilfreiche Websites",
    "text": "Hilfreiche Websites\n\nDokumentation\n\nR Documentation\ntidyverse\nggplot2 Reference\n\n\n\nCommunity\n\nR-bloggers\nStack Overflow (R Tag)\nRStudio Community\nReddit: r/rstats\n\n\n\nInspiration\n\nR Graph Gallery\nFrom Data to Viz",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#deutsche-ressourcen",
    "href": "referenzen.html#deutsche-ressourcen",
    "title": "Literatur & Ressourcen",
    "section": "Deutsche Ressourcen",
    "text": "Deutsche Ressourcen\n\nStatistik und R\nR-Kurs Material (Uni Münster)\nCrashkurs Statistik",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  },
  {
    "objectID": "referenzen.html#weiterführende-themen",
    "href": "referenzen.html#weiterführende-themen",
    "title": "Literatur & Ressourcen",
    "section": "Weiterführende Themen",
    "text": "Weiterführende Themen\n\nQuarto\nhttps://quarto.org/\nModerne Alternative zu R Markdown für reproduzierbare Berichte.\n\n\nShiny\nhttps://shiny.rstudio.com/\nInteraktive Web-Apps mit R erstellen.\n\n\nR Package Development\nhttps://r-pkgs.org/\nEigene R-Pakete entwickeln.\n\n\nStatistical Rethinking\nMcElreath, R. (2020). Statistical Rethinking: A Bayesian Course with Examples in R and Stan (2nd ed.).\nBayes’sche Statistik mit R.",
    "crumbs": [
      "Literatur & Ressourcen"
    ]
  }
]