# Daten aufbereiten {#sec-daten-transform}

```{r}
#| echo: false
source("Rsettings.R")

library(tidyverse)
library(kableExtra)
```

Datensätze liegen häufig nicht in der Form vor, die für Analyse oder Visualisierung benötigt wird. Daher müssen wir sie meist zunächst aufbereiten. Dazu gehört, relevante Variablen auszuwählen, Beobachtungen zu filtern, Datentypen zu korrigieren, neue Kennzahlen zu berechnen oder Informationen sinnvoll zusammenzufassen. Um diese Schritte zu illustrieren, verwenden wir den Palmer Penguins-Datensatz, der über das in Base R enthaltene Package `datasets` frei verfügbar ist:

```{r}
penguins <- datasets::penguins |>
  as_tibble()
glimpse(penguins)
```

Der `penguins` Datensatz enthält Informationen zu 344 Pinguinen mit den folgenden acht Variablen:

```{r}
#| label: tbl-penguins-data
#| tbl-cap: "Variablen im penguins-Datensatz"
#| echo: false

dplyr::tibble(
  var = names(penguins),
  descr = c(
    "Spezies des Pinguins (Adelie, Chinstrap, Gentoo)",
    "Insel, auf der der Pinguin beobachtet wurde (Biscoe, Dream, Torgersen)",
    "Schnabellänge in Millimetern",
    "Schnabeltiefe in Millimetern",
    "Flügellänge in Millimetern",
    "Körpergewicht in Gramm",
    "Geschlecht",
    "Jahr der Beobachtung"
  )
) |>
  kbl(
    col.names = c("Variable", "Beschreibung")
  ) |>
  kable_styling(
    full_width = F,
    bootstrap_options = "striped"
  )
```


## Dplyr

Zur Datenmanipulation verwenden wir das `dplyr` Package, das Teil von `tidyverse` ist. In diesem Kapitel lernen wir die wichtigsten `dplyr`-Funktionen kennen. Für eine ausführliche Einführung siehe Kapitel 3, 5 und 12–19 in [R for Data Science](https://r4ds.hadley.nz). Alle `dplyr`-Funktionen nehmen einen Datensatz (Data Frame oder Tibble) als erstes Argument, führen die gewünschte Operation aus und geben einen neuen Datensatz zurück. Solltest du das `tidyverse` noch nicht geladen haben, lade es mit `library(tidyverse)`.

:::callout-tip
#### Pipes

Komplexe Transformationen erfordern oft, mehrere `dplyr`-Funktionen zu kombinieren. Beispiel: Wir wollen einen Datensatz erstellen, der nur Pinguine der Insel Biscoe enthält und pro Spezies die durchschnittliche Schnabellänge berechnet:

```{r}
penguins_final <- filter(penguins, island == "Biscoe")
penguins_final <- group_by(penguins_final, species)
penguins_final <- summarise(penguins_final, bill_len = mean(bill_len, na.rm = T))
penguins_final
```

Für eine besser lesbare Verkettung von Funktionen werden wir in Zukunft Pipes (`|>`) verwenden. Pipes ermöglichen, dass das Ergebnis eines Ausdrucks direkt an die nächste Funktion übergeben wird, ohne dass man verschachtelte Klammern schreiben muss oder Objekte mehrfach definieren muss.

Eine Pipe übergibt das Ergebnis des linken Ausdrucks automatisch als erstes Argument an die Funktion rechts: `x |> f(y)` &harr; `f(x, y)` und `x |> f(y) |> g(z)` &harr; `g(f(x, y), z)`. Somit können wir den Code besser lesbar schreiben als:

```{r}
penguins |>
  filter(island == "Biscoe") |>
  group_by(species) |>
  summarize(bill_len = mean(bill_len, na.rm = T))
```
:::

## Tidy Data Sets

Daten können in unterschiedlicher Struktur dargestellt werden. Für die Arbeit in R eignet sich besonders das tidy data-Format. Es folgt drei Grundregeln:
- Jede Variable ist eine Spalte
- Jede Beobachtung ist eine Zeile
- Jede Zelle enthält genau einen Wert

Durch diese Struktur wird der Datensatz übersichtlich, leicht zu analysieren und kompatibel mit modernen R-Werkzeugen wie `dplyr` und `ggplot2`.

In unserem Übungsdatensatz `penguins` ist jede Zeile ein einzelner Pinguin und in den Spalten erhalten wir Informationen zu bestimmten Variablen (z.B. Spezies oder Geschlecht) für jede dieser Pinguin-Beobachtungen.

## Daten auswählen und sortieren

Bevor wir mit Analysen beginnen, müssen wir häufig relevanten Daten auswählen und sortieren, um den Datensatz übersichtlich zu halten. Mit `dplyr` erledigen wir dies z.B. mit `select()` zum Auswählen von Variablen, `filter()` oder `slice()` zum Filtern von Zeilen, `distinct()` und `drop_na()` zum Bereinigen von Duplikaten und fehlenden Werten sowie `arrange()` zum Sortieren. So können wir gezielt nur die Informationen betrachten, die für die Analyse wichtig sind.

### select()

`select()` ermöglicht es uns, nur die gewünschten Spalten eines Datensatzes zu behalten. Benötigen wir etwa nur Informationen zur Spezies, Insel und der Flügellänge können wir diese Variablen auswählen mit:

```{r}
penguins |>
  select(species, island, flipper_len)
```

Um eine Variable zu entfernen, setzen wir ein Minuszeichen davor:

```{r}
penguins |>
  select(-island)
```

:::callout-note
#### Hinweis

Damit der `penguins` Datensatz nicht immer wieder neu geladen werden muss, speichern wir Transformationen in diesem Kapitel nicht ab. In der eigenen Datenaufbereitung solltest du Änderungen einem Objekt zuweisen, damit diese erhalten bleiben:

```{r}
#| eval: false
penguins <- penguins |>
  select(-island)
```
:::

### filter()

Mit filter() können wir bestimmte Zeilen eines Datensatzes auswählen, die bestimmte Bedingungen erfüllen. So lassen sich gezielt Beobachtungen extrahieren, etwa alle Pinguine der Art Adelie oder alle Pinguine mit einer Schnabellänge von mindestens 40 Milimetern:

```{r}
penguins |>
  filter(species == "Adelie")
penguins |>
  filter(bill_len >= 40)
```

:::callout-tip
#### Logische Operatoren in R

Viele Schritte in der Datenaufbereitung setzen Kenntniss über logische Operatoren in R voraus. @tbl-logic-op fasst die wichtigsten zusammen:

```{r}
#| label: tbl-logic-op
#| tbl-cap: "Übersicht: Logische Operatoren in R"
#| echo: false

dplyr::tibble(
  var = c("==", "!=", "<", ">", "<=", ">=", "%in%", "!%in%", "&", "|"),
  descr = c(
    "gleich",
    "ungleich",
    "kleiner als",
    "größer als",
    "kleiner oder gleich",
    "größer oder gleich",
    "enthalten in",
    "nicht enthalten in",
    "logisches UND",
    "logisches ODER"
  ),
  exp = c(
    "species == \"Adelie\"",
    "species != \"Adelie\"",
    "bill_len < 40",
    "bill_len > 40",
    "bill_len <= 40",
    "bill_len >= 40",
    'species %in% c("Adelie", "Gentoo")',
    'species !%in% c("Adelie", "Gentoo")',
    "sex == \"female\" & island == \"Biscoe\"",
    "bill_len >= 45 | bill_len <= 35"
  )
) |>
  kbl(
    col.names = c("Operator", "Bedeutung", "Beispiel")
  ) |>
  kable_styling(
    full_width = F,
    bootstrap_options = "striped"
  )
```
:::

Wollen wir auf mehrere Konditionen gleichzeitig filtern, können wir diese in der Filter-Option angeben. Wir extrahieren weibliche Pinguine auf der Insel Biscoe mit:

```{r}
penguins |>
  filter(sex == "female" & island == "Biscoe")
```

Das Subset an Pinguinen, die eine Schnabellänge von mindestens 45mm oder eine Schnabellänge von höchstens 35mm haben filtern wir mit dem Oder-Operator `|`:

```{r}
penguins |>
  filter(bill_len >= 45 | bill_len <= 35)
```

Äquivalent zu den Base R Operatoren `&` und `|` sind die `dplyr`-Funktionen `when_all()` und `when_any()`:

```{r}
penguins |>
  filter(when_all(sex == "female", island == "Biscoe"))
penguins |>
  filter(when_any(bill_len >= 40, body_mass >= 4000))
```

:::callout-warning
#### Umgang mit NAs: filter_out()

Logische Bedingungen können bei fehlenden Werten ( (`NA`) Probleme verursachen. Wollen wir etwa alle weiblichen Pinguine aus dem Datensatz entfernen führt `penguins |> filter(sex != "female")` dazu, dass sowohl weibliche Pinguine als auch jene mit fehlender Geschlechtsinformation ausgeschlossen werden.

Mit `filter_out()` schließen wir nur Beobachtungen aus, auf welche die Kondition zutrifft:

```{r}
penguins |>
  filter_out(sex == "female")
```

Der Datensatz enthält jetzt keine weiblichen Pinguine mehr, aber jene mit fehlenden Werten sind weiterhin enthalten.
:::

### slice()

Manchmal möchten wir nur einen Teil des Datensatzes auswählen, ohne explizit nach bestimmten Werten zu filtern. Das ist besonders praktisch bei großen Datensätzen, wenn wir zunächst nur mit einem Sample arbeiten wollen, um Rechenressourcen zu schonen. Dafür nutzen wir `slice()`, zum Beispiel um die Zeilen 1, 3 und 6–8 aus dem `penguins`-Datensatz auszuwählen:

```{r}
penguins |>
  slice(1, 3, 6:8)
```

Für `slice()` steht eine Reihe hilfreicher Varianten zur Verfügung:
- `slice_head()`/`slice_tail()`: Nimmt die ersten/letzen N Beobachtungen eines Datensatzes (`penguins |> slice_head(n = 10)`)
- `slice_min()`/`slice_max()`: Nimmt die N Beobachtungen mit den niedrigsten/höchsten Werten einer Variable (`penguins |> slice_min(bill_len, n = 5)`)
- `slice_sample()`: Zieht zufällig N Beobachtungen aus dem gesamten Datensatz (`penguins |> slice_sample(n = 5)`). Für Reproduzierbarkeit sollte zuerst mit `set.seed()` ein Seed gesetzt werden.

:::callout-note
#### slice() mit gruppierten Daten

Haben wir den Datensatz mit `group_by()` in Gruppen klassifiziert, so wird die jeweilige slice-Operation auf jede Gruppe separat angewandt:

```{r}
penguins |>
  group_by(island) |>
  slice_max(bill_len, n = 2)
```
:::

### distinct()

Oft enthält ein Datensatz doppelte Zeilen, die für die Analyse nicht relevant sind. Mit `distinct()` können wir gezielt nur die einzigartigen Beobachtungen behalten und so Redundanzen entfernen. Zum Beispiel lassen sich im penguins-Datensatz alle verschiedenen Kombinationen aus Spezies und Insel extrahieren:

```{r}
penguins |>
  distinct(species, island)
```

Spezifizieren wir keine Variablen innerhalb von `distinct()`, so droppen wir alle Duplikate aus dem Datensatz (im `penguins` Datensatz gibt aber es keine zwei identen Beobachtungen). Mit der Option `.keep_all = TRUE` behalten wir die Informationen in allen weiteren Variablen für die erste distinkte Beobachtung:

```{r}
penguins |>
  distinct(species, island, .keep_all = TRUE)
```

### drop_na()

Oft enthalten Datensätze fehlende Werte (`NA`), die bestimmte Analysen oder Berechnungen stören können. Mit `drop_na()` können wir gezielt alle Zeilen entfernen, die in ausgewählten Variablen fehlende Werte enthalten, und so einen sauberen Datensatz erhalten. Zum Beispiel lässt sich im `penguins`-Datensatz nur jene Beobachtungen behalten, bei denen die Schnabeltiefe nicht fehlt:

```{r}
penguins |>
  drop_na(bill_dep)
```

Spezifizieren wir keine Variable innerhalb von `drop_na()`, so werden sämtliche Beobachtungen mit zumindest einem fehlenden Wert in einer der Variablen ausgeschlossen (`penguins |> drop_na()`).

:::callout-warning
#### Gefahren beim Entfernen fehlender Werte

Man sollte mit `drop_na()` vorsichtig sein, weil beim Entfernen von Zeilen mit fehlenden Werten unter Umständen wichtige Daten verloren gehen. Gerade wenn viele Variablen NA-Werte enthalten, kann das zu einer stark verkleinerten Stichprobe führen und die Analyse verzerren. Deshalb sollte man vorher prüfen, wie viele Werte betroffen sind und überlegen, ob alternative Strategien wie Imputation oder gezieltes Entfernen nur einzelner Spalten sinnvoller sind.
:::

### arrange()

Mit `arrange()` können wir die Zeilen eines Datensatzes nach einer oder mehreren Variablen sortieren. So lassen sich Daten übersichtlicher darstellen, Extremwerte leicht erkennen oder vorbereitend für weitere Analysen ordnen, ohne den Datensatz inhaltlich zu verändern.

```{r}
penguins |>
  arrange(bill_len, bill_dep)
```

Wenn mehr als eine Variable angeführt ist, ordnet `arrange()` zuerst nach der erstgenannten und nur bei Gleichstand nach den weiteren Variablen. Fehlende Werte werden immer als letztes angeordnet. Per Default ordnet `arrange()` von unten nach oben. Wollen wir vom Maximum aus sortieren, verwenden wir `desc()` innerhalb von `arrange()`:

```{r}
penguins |>
  arrange(desc(bill_len))
```

## Variablen verändern und erstellen

### mutate()

### case_when() & replace_when()

### recode_values() & replace_values()

## Gruppieren und Zusammenfassen

### group_by()

### summarize()

### count()

## Datensätzen verbinden

### bind_rows() & bind_cols()
 
### inner_join(), left_join(), full_join()

## Datensatz umformen

### pivot_longer()

### pivot_wider()

## Weitere Themen 

### Strings und Regular Expressions

### Datum und Zeit

### Fehlende Werte
